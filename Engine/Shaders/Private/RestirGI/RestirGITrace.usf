#define USE_IES_TERM 0 // this shader doesn't bind the IES atlas, so disable the IES term from path tracer lights
#include "../Common.ush"
#include "../RectLight.ush"
//#include "../MonteCarlo.ush"
#include "../DeferredShadingCommon.ush"
#include "../ShadingModels.ush"
#include "../SceneTextureParameters.ush"
#include "../RayTracing/RayTracingCommon.ush"
#include "../RayTracing/RayTracingDeferredShadingCommon.ush"
#include "../RayTracing/RayTracingHitGroupCommon.ush"

// #include "../RayTracing/RayTracingTimingCommon.ush"

#include "../PathTracing/Light/PathTracingLightSampling.ush"
#include "../PathTracing/Material/PathTracingMaterialSampling.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "ReservoirManagement.ush"
#include "RandomNumberUtils.ush"

#define USE_PATHTRACING_MATERIALS 0

RaytracingAccelerationStructure TLAS;
RWTexture2D<float4> RWGlobalIlluminationUAV;
RWTexture2D<float2> RWGlobalIlluminationRayDistanceUAV;

int     HistoryReservoir;
int     InitialCandidates;
int     OutputSlice;
uint    UpscaleFactor;
float   LongPathRatio;

uint    MaxBounces;
float   MaxRayDistanceForGI;
float   MaxRayDistanceForAO;
float   MaxShadowDistance;
float   NextEventEstimationSamples;
float   DiffuseThreshold;
uint    EvalSkyLight;
uint    UseRussianRoulette;
uint    UseFireflySuppression;
float   MaxNormalBias;

#if USE_SURFEL
#include "../SurfelGI/SurfelCommon.ush"
ByteAddressBuffer SurfelMetaBuf;
ByteAddressBuffer SurfelHashKeyBuf;
ByteAddressBuffer SurfelHashValueBuf;
StructuredBuffer<SurfelVertexPacked> SurfelVertexBuf;
ByteAddressBuffer CellIndexOffsetBuf;
ByteAddressBuffer SurfelIndexBuf;
StructuredBuffer<float4> SurfelIrradianceBuf;
#include "../SurfelGI/SurfelGridHash.ush"
#endif


void GenerateCosineNormalRay(
	float3 WorldPosition,
	float3 WorldNormal,
	float2 RandSample,
	out float3 RayOrigin,
	out float3 RayDirection,
	out float RayTMin,
	out float RayTMax,
	out float RayPdf
)
{
#if COSINE_TARGET_PDF
	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
#else
	float4 Direction_Tangent = UniformSampleHemisphere(RandSample);
#endif
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayOrigin = WorldPosition;
	RayDirection = Direction_World;
	RayTMin = 0.01;
	RayTMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
	RayPdf = Direction_Tangent.w;
}

void ProduceInitialSample(uint2 DispatchId,uint2 PixelCoord, FGBufferData GBuffer, float DeviceZ, float3 WorldPosition, float3 CameraDirection, inout FRandomContext RandContext, inout RTXGI_Reservoir state)
{
	const uint2 TileSize = uint2(64,32);
	const uint2 TiledIndex = uint2(PixelCoord.x / TileSize.x, PixelCoord.y / TileSize.y);
	const uint2 TileDim = uint2( ( View.ViewSizeAndInvSize.x +TileSize.x -1) / TileSize.x, ( View.ViewSizeAndInvSize.y +TileSize.y -1) / TileSize.y);
	const uint TileLinearIndex = TiledIndex.y * TileDim.x + TiledIndex.x;
	FRandomContext RandGen = FRandomContext::Create(TileLinearIndex, View.StateFrameIndex + HistoryReservoir * 32);
	const bool bRussian = RandGen.GenerateSample1D() < (1 - LongPathRatio);

	const int NumSamples = InitialCandidates;

	RTXGI_Reservoir LocalReservoir = RTXGI_Reservoir::Empty();

	float3 DiffuseColor = GBuffer.DiffuseColor;
	float3 WorldNormal = GBuffer.WorldNormal;

	float HitDistance = 0.0;
	float HitCount = 0.0;

	for (uint SampleIndex = 0; SampleIndex < NumSamples; SampleIndex++)
	{
		RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, PixelCoord, SampleIndex, View.StateFrameIndex, NumSamples);
		float3 RayThroughput = 1.0;
		float3 RandSample = RandomSequence_GenerateSample3D(RandSequence);

		RTXGI_SampleRef sampleRef;

		// Initialize ray
		RayDesc Ray;
		float3 Irradiance = 0;
		float RayPdf = 1.0;
		GenerateCosineNormalRay(WorldPosition, WorldNormal, RandSample.yz, Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RayPdf);
		
		// half3 N = WorldNormal;
		// half3 V = -CameraDirection;
		// half3 L = Ray.Direction;
		// float NoL = saturate(dot(N, L));
		// FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
		// FDirectLighting LightingSample = EvaluateBxDF(GBuffer, N, V, L, NoL, ShadowTerms);
		// RayThroughput *= LightingSample.Diffuse / DiffuseColor;
		
		Ray.TMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
		ApplyCameraRelativeDepthBias(Ray, PixelCoord, DeviceZ, WorldNormal, MaxNormalBias);
		
		float MaterialPdf = 0.0;
		uint Bounce = 0;
		#if !USE_SURFEL
		while (Bounce < MaxBounces)
		#endif
		{
			// Cast ray
			uint RayFlags = 0;
			const uint InstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;
			const bool bEnableSkyLightContribution = true;
			const bool bIgnoreTranslucentMaterials = false;

#if !ENABLE_TWO_SIDED_GEOMETRY
			RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

			FRayCone RayCone = (FRayCone)0;
			FMaterialClosestHitPayload Payload = TraceMaterialRay(
				TLAS,
				RayFlags,
				InstanceInclusionMask,
				Ray,
				RayCone,
				PixelCoord,
				bEnableSkyLightContribution,
				bIgnoreTranslucentMaterials);

			// Environment hit
			if (Payload.IsMiss())
			{
				// Optional multi-bounce SkyLight contribution
				if (EvalSkyLight && Bounce > 0)
				{
					uint SkyLightId = 0;
					RayDesc LightRay = Ray;
					LightRay.TMax = POSITIVE_INFINITY;
					float3 EnvironmentRadiance = SkyLight_TraceLight(Ray, SkyLightId).Radiance;
					Irradiance += EnvironmentRadiance * RayThroughput / RayPdf;
				}
				break;
			}

			#if !USE_SURFEL
			if (Bounce == 0)
			#endif
			{
				float3 HitPos = Ray.Origin + Ray.Direction * Payload.HitT;
				// sampleRef.Create( samPos,Payload.WorldNormal, WorldPosition, GBuffer.WorldNormal );
				sampleRef.CreationPoint = WorldPosition;
				sampleRef.CreationNormal = WorldNormal;
				sampleRef.Position = HitPos;
				sampleRef.Normal = Payload.WorldNormal;
				
				HitDistance += Payload.HitT;
				HitCount += 1.0;
			}
			if (Payload.HitT > MaxRayDistanceForGI) break;

			// Update intersection
			Ray.Origin += Ray.Direction * Payload.HitT;

			//Create faux GBuffer to use with EvaluateBxDF
			FGBufferData GBufferData = (FGBufferData)0;
			GBufferData.Depth = 1.f; // Do not use depth
			GBufferData.WorldNormal = Payload.WorldNormal;
			GBufferData.BaseColor = Payload.BaseColor;
			GBufferData.CustomData = Payload.CustomData;
			GBufferData.GBufferAO = Payload.GBufferAO;
			GBufferData.IndirectIrradiance = (Payload.IndirectIrradiance.x + Payload.IndirectIrradiance.y + Payload.IndirectIrradiance.z) / 3.f;
			GBufferData.SpecularColor = Payload.SpecularColor;
			GBufferData.DiffuseColor = Payload.DiffuseColor;			
			GBufferData.Metallic = Payload.Metallic;
			GBufferData.Specular = Payload.Specular;
			GBufferData.Roughness = Payload.Roughness;
			GBufferData.ShadingModelID = Payload.ShadingModelID;
			GBufferData.CustomData = Payload.CustomData;

			// if (AccumulateEmissive)
			// {
			// 	Irradiance += Payload.Radiance;
			// }

			//Perform next-event estimation
			float SplitFactor = 1.0 / NextEventEstimationSamples;
			// float SplitFactor = 1.0 / 1;
			for (uint NeeTrial = 0; NeeTrial < NextEventEstimationSamples; ++NeeTrial)
			{
				// Light selection
				int LightId;
				float3 LightRadianceOverPdf = 0;
				float NeePdf = 0.0;

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);

				RayDesc LightRay;
				if (SampleLight(RandSample3,
								Ray.Origin,
								Payload.WorldNormal,
								Payload.PrimitiveLightingChannelMask,
								ENABLE_TRANSMISSION,
								LightId,
								LightRay.Direction,
								LightRay.TMax,
								LightRadianceOverPdf,
								NeePdf))
				{
					LightRay.Origin = Ray.Origin;
					LightRay.TMin = 0;
					LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
					bool bTransmission = HasTransmission(LightId);
					float3 BiasNormal = Payload.WorldNormal;
					if (bTransmission && dot(BiasNormal, LightRay.Direction) < 0.0)
					{
						BiasNormal = -BiasNormal;
					}
					ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

					// Trace visibility ray
					uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
					const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
					NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

					FMinimalPayload NeePayload = TraceVisibilityRay(
						TLAS,
						NeeRayFlags,
						NeeInstanceInclusionMask,
						PixelCoord,
						LightRay);

					// No hit indicates successful next-event connection
					if (NeePayload.IsMiss())
					{
						// Evaluate material
						float3 MaterialThroughput;
						float MaterialEvalPdf = 0.0;
#if USE_PATHTRACING_MATERIALS
						float3 MaterialWeight = 0;
						EvalMaterial(Ray.Direction, LightRay.Direction, Payload, MaterialWeight, MaterialEvalPdf);
						MaterialThroughput = MaterialWeight * MaterialEvalPdf;
#else
						half3 N = Payload.WorldNormal;
						half3 V = -Ray.Direction;
						half3 L = LightRay.Direction;
						float NoL = saturate(dot(N, L));
						FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
						FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
						MaterialThroughput = LightingSample.Diffuse;
						if (bTransmission)
						{
							MaterialThroughput += LightingSample.Transmission;
						}
						MaterialEvalPdf = 1.0;
#endif

						// Record the contribution
						float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput * RayThroughput * SplitFactor ;

						Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
					}
				}
			}

			// Perform material sampling
#if !USE_SURFEL
			if (Bounce + 1 < MaxBounces)
			{
				float3 Direction;
				float3 Throughput = 1.0;
#if USE_PATHTRACING_MATERIALS
				RandSample4 = RandomSequence_GenerateSample4D(RandSequence);

				float PositionBiasSign;
				float3 Weight = 0;
				SampleMaterial(Ray.Direction, Payload, RandSample, Direction, Weight, MaterialPdf, PositionBiasSign);
				Throughput = Weight * MaterialPdf;
#else

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);

				float3 RayOrigin = Ray.Origin;
				GenerateCosineNormalRay(RayOrigin, Payload.WorldNormal, RandSample3.xy, Ray.Origin, Direction, Ray.TMin, Ray.TMax, MaterialPdf);
				
				half3 N = Payload.WorldNormal;
				half3 V = -Ray.Direction;
				half3 L = Direction;
				float NoL = saturate(dot(N, L));
				FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
				FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
				Throughput = LightingSample.Diffuse;
#endif
				if (MaterialPdf <= 0.0)
				{
					break;
				}

				// Update ray
				Ray.Direction = Direction;
				RayThroughput *= Throughput;
				RayPdf *= MaterialPdf;

				// Russian roulette based on DiffuseColor
				float2 Rand = RandomSequence_GenerateSample2D(RandSequence);
				
				// float Ratio = 1 - LongPathRatio;
				if( bRussian )
				{	
					// if ( Rand.y < Ratio )
					{
						float RRSample = Rand.x;
						// float ProbabilityOfSuccess = Luminance(DiffuseColor);
						float3 PathT = RayThroughput * DiffuseColor / RayPdf;
						float ProbabilityOfSuccess = max(max(PathT.x, PathT.y), PathT.z);
						float ProbabilityOfTermination = 1.0 - ProbabilityOfSuccess;
						if (RRSample < ProbabilityOfTermination) break;
						RayThroughput /= ProbabilityOfSuccess;
					}
				}

			}
			Bounce++;
#else
			Irradiance += GBufferData.DiffuseColor * GetSurfelGI(Ray.Origin, GBufferData.WorldNormal);
#endif
		}
	
		sampleRef.Irradiance = Irradiance;
		// float pdfScale = 1.0;
		// float weight = Luminance(sampleRef.Irradiance);
		float targetPdf = GetTargetPdf(sampleRef.Irradiance, sampleRef.CreationPoint,sampleRef.CreationNormal, sampleRef.Position);	
		float invSourcePdf = 1.0;
		float risRnd = RandContext.GenerateSample1D();

		bool selected = LocalReservoir.StreamSample(sampleRef, risRnd, targetPdf, invSourcePdf);
	}
	LocalReservoir.FinalizeResampling(1.0, LocalReservoir.M);
	LocalReservoir.M = 1;

	// state = RTXGI_Reservoir::Empty();
	state = LocalReservoir;
	if (HitCount > 0.0)
	{
		HitDistance /= HitCount;
	}
	else
	{
		HitDistance = -1.0;
	}
	RWGlobalIlluminationRayDistanceUAV[DispatchId] = float2(HitDistance, NumSamples);
}

/***************************************************************************************************
 *
 *  GenerateInitialSamples
 *
 ***************************************************************************************************/
RAY_TRACING_ENTRY_RAYGEN(GenerateInitialSamplesRGS)
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy + View.ViewRectMin.xy;
	uint2 PixelCoord = GetPixelCoord(DispatchThreadId, UpscaleFactor);
	uint LinearIndex = CalcLinearIndex(PixelCoord);
	FRandomContext RandContext = FRandomContext::Create(LinearIndex, View.StateFrameIndex + HistoryReservoir * 32);

	// Get G-Buffer surface data
	FGBufferData GBuffer = GetGBufferDataFromSceneTexturesLoad(PixelCoord);

	float Depth = GBuffer.Depth;
	float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;


	float3 WorldPosition;
	float3 CameraDirection;
	ReconstructTranslatedWorldPositionAndCameraDirectionFromDeviceZ(PixelCoord, DeviceZ, WorldPosition, CameraDirection);
	// Remap DiffuseColor when using SubsurfaceProfile (GBuffer decoding replaces with 100% albedo)
	if (UseSubsurfaceProfile(GBuffer.ShadingModelID))
	{
		GBuffer.DiffuseColor = GBuffer.StoredBaseColor;
	}
	RTXGI_Reservoir state = RTXGI_Reservoir::Empty();
	// Diffuse color rejection threshold
	float3 DiffuseColor = GBuffer.DiffuseColor;
	const bool bIsDepthValid = DeviceZ > 0.0;
	const bool bIsValidPixel = GBuffer.ShadingModelID != SHADINGMODELID_UNLIT && bIsDepthValid && Luminance(DiffuseColor) > DiffuseThreshold;

	if (bIsValidPixel)
	{
		ProduceInitialSample(DispatchThreadId,PixelCoord, GBuffer, DeviceZ, WorldPosition, CameraDirection, RandContext, state);
	}

	WriteReservoirData(DispatchThreadId, OutputSlice, state.Store());
}