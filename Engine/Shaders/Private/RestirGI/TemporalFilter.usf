

#include "../Common.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"
#include "../ColorSpace.ush"
#include "../Bilinear.ush"

Texture2D   DepthTexture;
Texture2D   VelocityTexture;
Texture2D   NormalTexture;

Texture2D   DepthHistory;
Texture2D   NormalHistory;

Texture2D   InputTex;
Texture2D   HistoryTex;
Texture2D   VarianceHistoryTex;
RWTexture2D<float4> RWOutputTex;
RWTexture2D<float4> RWHistoryTex;
RWTexture2D<float2> RWVarianceTex;

Texture2D   ReprojectionTex;

SamplerState        LinearClampSampler;
SamplerState        PointClampSampler;  
float4              BufferTexSize;
float               TemporalNormalRejectionThreshold;
float               TemporalDepthRejectionThreshold;
float               HistroryClipFactor;
float               MaxLowSpp;
float3 rgb_to_ycbcr(float3 col) 
{
    float3x3 m = float3x3(0.2126, 0.7152, 0.0722, -0.1146,-0.3854, 0.5, 0.5,-0.4542,-0.0458);
    return mul(m, col);
}

float3 ycbcr_to_rgb(float3 col) 
{
    float3x3 m = float3x3(1.0, 0.0, 1.5748, 1.0, -0.1873, -.4681, 1.0, 1.8556, 0.0);
    return max(0.0, mul(m, col));
}


float4 linear_rgb_to_crunched_luma_chroma(float4 v) 
{
    v.rgb = rgb_to_ycbcr(v.rgb);
    float k = sqrt(v.x) / max(1e-8, v.x);
    return float4(v.rgb * k, v.a);
}

float4 crunched_luma_chroma_to_linear_rgb(float4 v) 
{
    v.rgb *= v.x;
    v.rgb = ycbcr_to_rgb(v.rgb);
    return v;
}

#define linear_to_working linear_rgb_to_crunched_luma_chroma
#define working_to_linear crunched_luma_chroma_to_linear_rgb
float working_luma(float3 v) { return v.x; }


#define RESET_HISTORY 0
#define REPROJECT_HISTORY 1
static const int TARGET_COUNT = 64;
[numthreads(8, 8, 1)]
void TemporalFilter(uint2 DispatchThreadId: SV_DispatchThreadID) 
{
#if DIM_STAGE == RESET_HISTORY   //first frame
    float4 Current = linear_to_working(InputTex[DispatchThreadId]);
    const float CurrentLum = working_luma(Current.xyz);
    const float2 CurrentMoment = float2(max(0,CurrentLum), CurrentLum * CurrentLum);
    RWVarianceTex[DispatchThreadId] = CurrentMoment;
    RWHistoryTex[DispatchThreadId] = working_to_linear(float4(Current.xyz, 1.0));
#elif DIM_STAGE == REPROJECT_HISTORY
    uint2  PixelCoord = DispatchThreadId;
    float2 ViewUV = (float2(PixelCoord) + 0.5) * BufferTexSize.zw;
    float4 center = HistoryTex[PixelCoord];
    float4 reproj = ReprojectionTex[PixelCoord];
    float2 PrevUV = ViewUV + reproj.xy;

    uint QuadReprojValidPacked = uint(reproj.z * 15.0 + 0.5);

    // // For the sharpening (4x4) kernel, we need to know whether our neighbors are valid too,
    // // as otherwise we end up over-sharpening with fake history (moving edges rather than scene features).
    const uint4 ReprojValidNeigh =
        uint4(ReprojectionTex.GatherBlue(PointClampSampler, ViewUV + 0.5 * sign(PrevUV) * BufferTexSize.zw) * 15.0 + 0.5);

    float4 history = 0.0.xxxx;

    if (0 == QuadReprojValidPacked) 
    {
        // Everything invalid
    } 
    else if (15 == QuadReprojValidPacked) 
    {
        if (all(ReprojValidNeigh == 15)) 
            history = max(0.0.xxxx, ImageSampleCatmullRom(HistoryTex, PrevUV,BufferTexSize.xy));
        else
            history = HistoryTex.SampleLevel(LinearClampSampler, PrevUV, 0);

    }
    else 
    {
        // Only some samples are valid. Only include those, and don't do a sharpening fetch here.
        float4 QuadReprojValid = (QuadReprojValidPacked & uint4(1, 2, 4, 8)) != 0;

        const Bilinear bilinear = GetBilinearFilter(saturate(PrevUV), BufferTexSize.xy);
        float4 s00 = HistoryTex[int2(bilinear.Origin) + int2(0, 0)];
        float4 s10 = HistoryTex[int2(bilinear.Origin) + int2(1, 0)];
        float4 s01 = HistoryTex[int2(bilinear.Origin) + int2(0, 1)];
        float4 s11 = HistoryTex[int2(bilinear.Origin) + int2(1, 1)];

        float4 weights = GetBilinearCustomWeights(bilinear, QuadReprojValid);

        if (dot(weights, 1.0) > 1e-5) 
            history = ApplyBilinearCustomWeights(s00, s10, s01, s11, weights);
    }

    RWHistoryTex[PixelCoord] = history;
#else
    uint2 PixelCoord = DispatchThreadId;
    // Backproject this pixel to last frame
    // start by just using our sample position
    int2 PrevPos = DispatchThreadId;

    float2 ViewUV = (float2(PixelCoord) + 0.5) * BufferTexSize.zw;
    float4 Reproject = ReprojectionTex[PixelCoord];
    float2 PrevUV = ViewUV + Reproject.xy;
   
    float4 Current = linear_to_working(InputTex[DispatchThreadId]);
    float4 History = linear_to_working(HistoryTex[PrevPos]);

    float4 ValueSum = 0;
    float4 ValueSum2 = 0;
    float WeightSum = 0.0;
    float HistDiff = 0.0;
    float HistValueSum = 0.0;
    float HistValueSum2 = 0.0;

    const int Radius = 2;
    const int Kernel = Radius + 1;
    for (int y = -Radius; y <= Radius; ++y) 
    {
        for (int x = -Radius; x <= Radius; ++x) 
        {
            float4 Neighbor = linear_to_working(InputTex[DispatchThreadId + int2(x,y)]);
            float4 HistNeighbor = linear_to_working(HistoryTex[PrevPos + int2(x,y)]);

            float  NeighLum = working_luma(Neighbor.xyz);
            float  HistNeighLum = working_luma(HistNeighbor.xyz);

            float Weight = exp(-4.0 * float(x*x + y * y) / float(Kernel * Kernel));
            ValueSum += Neighbor * Weight;
            ValueSum2 += Neighbor * Neighbor * Weight;
            WeightSum += Weight;

            HistDiff += abs(NeighLum - HistNeighLum) / max(1e-5,NeighLum + HistNeighLum ) * Weight;
            HistValueSum += HistNeighLum * Weight;
            HistValueSum2 += HistNeighLum * HistNeighLum * Weight;
        }
    }
    //normalize
    float4 Ex = ValueSum / WeightSum;
    float4 Ex2 = ValueSum2 / WeightSum;
    float4 Dev = sqrt(max(0.0.xxxx, Ex2 - Ex * Ex));
    HistDiff /= WeightSum;
    HistValueSum /= WeightSum;
    HistValueSum2 /= WeightSum;

    const float2 HistoryMoment = VarianceHistoryTex.SampleLevel(LinearClampSampler, PrevUV, 0);

    const float CurrentLum = working_luma(Current.xyz) + HistValueSum - working_luma(Ex.rgb);
    const float2 CurrentMoment = float2(CurrentLum, CurrentLum * CurrentLum);
    const float TemporalDev = sqrt(max(0.0, HistoryMoment.y - HistoryMoment.x * HistoryMoment.x));

    //float3 HistDev = sqrt(abs(HistValueSum2 - HistValueSum * HistValueSum));
    float  TemporalChange = abs(HistValueSum - working_luma(Ex.rgb)) / max(1e-8, HistValueSum + working_luma(Ex.rgb));

    const float VarianceAdjustedTemporalChange = smoothstep(0.1, 1.0, 0.05 * TemporalChange / TemporalDev);

    float HistorySpp = min(History.a, TARGET_COUNT);
    float2 MovePixel = Reproject.xy * BufferTexSize.xy ;
    // float  MoveFactor = 1.0 / max(length(MovePixel), 1.0);
    float MoveFactor = lerp(1, 0.25, saturate(length(MovePixel) / 10.0));
    float ClampBoxSize = lerp(0.25, 1.0, pow(saturate(HistorySpp / TARGET_COUNT), 2)) * HistroryClipFactor * MoveFactor;
    ClampBoxSize = max(ClampBoxSize, 0.5);

	float4 NMin = Current - Dev * ClampBoxSize;
	float4 NMax = Current + Dev * ClampBoxSize;

	float4 ClampedHistory = float4(clamp(History.rgb, NMin.rgb, NMax.rgb), History.a);
    // float4 ClampedHistory = History;
    float MaxSpp = TARGET_COUNT;
    MaxSpp = lerp(MaxSpp, MaxLowSpp, VarianceAdjustedTemporalChange);

    float3 BlendColor = lerp(ClampedHistory.rgb, Current.rgb, 1.0 / (1.0 + min(MaxSpp, HistorySpp)));

    const float CurSpp = min(HistorySpp, MaxSpp) + 1;
    float4 Output = working_to_linear(float4( BlendColor, CurSpp));

    float varianceFactor =  min(0.25, saturate((HistorySpp+1)/ TARGET_COUNT));
    RWVarianceTex[DispatchThreadId] = max(0.0, lerp(HistoryMoment, CurrentMoment, 0.25));

    RWHistoryTex[DispatchThreadId] = Output;
    RWOutputTex[DispatchThreadId] = float4(Output.rgb, saturate(CurSpp / TARGET_COUNT));
#endif
}