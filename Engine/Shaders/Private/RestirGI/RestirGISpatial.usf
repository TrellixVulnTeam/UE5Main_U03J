#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "../SceneTextureParameters.ush"
#include "../ScreenSpaceDenoise/SSDPublic.ush"
#include "../MortonCode.ush"
#include "../BRDF.ush"

#include "../RayTracing/RayTracingCommon.ush"
#include "../RayTracing/RayTracingReflectionsCommon.ush"
#include "../RayTracing/RayTracingDeferredReflections.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush" 

#include "ReservoirManagement.ush"
#include "RandomNumberUtils.ush"

Texture2D<float4>   SSAOTex;

float   DiffuseThreshold;
uint    UpscaleFactor;
uint    SpatialSamples;
uint    SpatialPassIdx;
int     MaxTemporalHistory;

float   SpatialDepthRejectionThreshold;
float   SpatialNormalRejectionThreshold;
int     InputSlice;
int     OutputSlice;
int     HistoryReservoir;

// [numthreads(8, 8, 1)]
// void SpatialResamplingCS(uint2 DispatchThreadID : SV_DispatchThreadID) 
// {
//     uint2 DispatchThreadId = DispatchThreadID.xy + View.ViewRectMin.xy;
// 	uint2 PixelCoord = GetPixelCoord(DispatchThreadId, UpscaleFactor);
// 	if (any(PixelCoord >= View.ViewSizeAndInvSize.xy))
// 	{
// 		return;
// 	}

// 	const float2 BufferUV = (PixelCoord + 0.5) * View.BufferSizeAndInvSize.zw;
//     const float2 ViewportUV = BufferUVToViewportUV(BufferUV);
// 	const float2 ScreenPos = ViewportUVToScreenPos(ViewportUV);

// 	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);
// 	float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;

//     float SceneDepth = ConvertFromDeviceZ(DeviceZ);

// 	float3 TranslatedWorldPosition = ReconstructTranslatedWorldPositionFromDeviceZ(PixelCoord, DeviceZ);
    
//     float3 WorldNormal = GBuffer.WorldNormal;
//     uint LinearIndex = CalcLinearIndex(PixelCoord);
// 	FRandomContext RandContext = FRandomContext::Create(LinearIndex, View.StateFrameIndex + HistoryReservoir * 32);
    
// 	RTXGI_Reservoir state = RTXGI_Reservoir::Empty();
// 	float3 DiffuseColor = GBuffer.DiffuseColor;
// 	const bool bIsDepthValid = DeviceZ > 0.0 && DeviceZ < 0.999 ;
// 	const bool bIsValidPixel = GBuffer.ShadingModelID != SHADINGMODELID_UNLIT && bIsDepthValid && Luminance(DiffuseColor) > DiffuseThreshold;

//     if (bIsValidPixel)
//     {
//         float SampleRadiusOffset = RandContext.GenerateSample1D();
//         const float CenterSSAO = SSAOTex[PixelCoord].r;
//         RTXGI_Reservoir centerSample = RTXGI_Reservoir::Load(ReadReservoirData(DispatchThreadId, InputSlice));
//         state.CombineReservoirs(centerSample, /* random = */ 0.5f, centerSample.targetPdf);
       
//         // Don't be picky at low contribution counts. SSAO weighing
//         // in those circumstances results in boiling near edges.
//         const float SSAOFactor = smoothstep(5.0, 10.0, centerSample.M);
//         float KernelRadius = lerp(2.0, 16.0, lerp(1, CenterSSAO, SSAOFactor));

//         if (SpatialPassIdx == 1) 
//         {
//             KernelRadius = lerp(2.0, 32.0, lerp(1, CenterSSAO, SSAOFactor));
//         }

//         const uint TARGET_M = 512;
//         float AngleOffset = RandContext.GenerateSample1D() * PI * 2;

//         for (uint SampleIndex = 1; SampleIndex < SpatialSamples && state.M < TARGET_M; ++SampleIndex) 
//         {
//             //float ang = M_PI / 2;
//             float Angle = (SampleIndex + AngleOffset) * GOLDEN_ANGLE;
//             float Radius =  float(SampleIndex + SampleRadiusOffset) * (KernelRadius / SpatialSamples);
//             int2  RpxOffset = float2(cos(Angle), sin(Angle)) * Radius;
//             const int2 SampleCoord = DispatchThreadId + RpxOffset;
//             const float2 SampleUV = (SampleCoord + 0.5) * View.BufferSizeAndInvSize.zw;
//             // Read adjacent GBuffer data
//             FGBufferData AdjGBuffer = GetGBufferDataFromSceneTextures(SampleUV);
//             float AdjDeviceZ = SceneDepthTexture.Load(int3(SampleCoord, 0)).r;
//             float3 AdjWorldPosition;
//             float3 AdjCameraDirection;
//             ReconstructTranslatedWorldPositionAndCameraDirectionFromDeviceZ(SampleCoord, AdjDeviceZ, AdjWorldPosition, AdjCameraDirection);

//             // TODO: refine sample rejection tests
//             if (dot(GBuffer.WorldNormal, AdjGBuffer.WorldNormal) < SpatialNormalRejectionThreshold)
//             {
//                 continue;
//             }

//             if (abs(GBuffer.Depth - AdjGBuffer.Depth) / GBuffer.Depth > SpatialDepthRejectionThreshold)
//             {
//                 continue;
//             }

//             if (GBuffer.ShadingModelID != AdjGBuffer.ShadingModelID)
//             {
//                 continue;
//             }
//             uint2 samplePosID = clamp(SampleCoord , uint2(0,0), ReservoirBufferDim.xy - 1);
//             RTXGI_Reservoir r = RTXGI_Reservoir::Load(ReadReservoirData(samplePosID, InputSlice));
//             r.M = min(500, r.M);
//             if (r.sampleRef.IsValid())
//             {			
//                 //ToDo - does this need to be a permutation?
//                 bool Visible = true;
//                 float pNewTN = GetTargetPdf(r.sampleRef.Irradiance, WorldNormal, TranslatedWorldPosition, r.sampleRef.Position);
//                 float neighborWeight = Visible ?  pNewTN  : 0;
//                 state.CombineReservoirs(r, RandContext.GenerateSample1D(), neighborWeight);
//             }
//         }
//     }
    	
// 	WriteReservoirData(DispatchThreadId, OutputSlice, state.Store());
// }


/***************************************************************************************************
 *
 *  ApplySpatialResampling
 *
 *
 ***************************************************************************************************/
//

void ApplySpatialResampling(uint2 PixelCoord,uint2 DispatchID, FGBufferData GBuffer, float DeviceZ, float3 WorldPosition, float3 CameraDirection, inout FRandomContext RandContext, inout RTXGI_Reservoir state)
{
	uint cachedResult = 0x0u;

	float normalizationWeight = 1.0f;

	RTXGI_Reservoir centerSample = RTXGI_Reservoir::Load(ReadReservoirData(DispatchID, InputSlice));

	float3 selectedPos;
	float3 selectedNormal;
	float3 selectedLi;
	int selected = -1;

	if (centerSample.sampleRef.IsValid() )
	{
		selectedPos = centerSample.sampleRef.Position;
		selectedNormal = centerSample.sampleRef.Normal;
		selectedLi = centerSample.sampleRef.Irradiance;
		selected = true;
	}

	state.CombineReservoirs(centerSample, /* random = */ 0.5f, centerSample.targetPdf);

	float3 WorldNormal = GBuffer.WorldNormal;
	//
	// Walk the specified number of neighbors, resampling using RIS
	//

	// Two sample modes for spatial resampling
	//   predefined low-discrepency sequence
	//   random data stored in local array for use with second pass
	int NumSamples = SpatialSamples;
	if (centerSample.M < MaxTemporalHistory)
	{
		NumSamples = max(NumSamples, SpatialSamplesBoost);
	}

#if !USE_LDS_FOR_SPATIAL_RESAMPLE
	NumSamples = min(NumSamples, MAX_SPATIAL_SAMPLES);

	int2 SamplePoints[MAX_SPATIAL_SAMPLES] = (int2[MAX_SPATIAL_SAMPLES])0;
#else
	uint StartIdx = RandContext.GenerateSample1D() * NeighborOffsetMask;

	// using uint mask to track samples, so absolute limit is 32
	NumSamples = min(NumSamples, 32);
	// NumSamples = min(NumSamples, 300);
#endif

	for (int i = 0; i < NumSamples; ++i)
	{

#if !USE_LDS_FOR_SPATIAL_RESAMPLE
		float2 Offset = RandContext.GenerateSample2D() * 2.0f - 1.0f;
		int2 SampleCoord = round(float2(PixelCoord) + (Offset * SpatialSamplingRadius));

		SamplePoints[i] = SampleCoord;
#else
		float2 Offset = NeighborOffsets[(StartIdx + i) & NeighborOffsetMask] * 2.0f - 1.0f;
		int2 SampleCoord = round(float2(PixelCoord) + (Offset * SpatialSamplingRadius));
#endif

		if (any(SampleCoord < 0) || any(SampleCoord >= View.BufferSizeAndInvSize.xy) || all(SampleCoord == PixelCoord))
		{
			continue;
		}

		// Read adjacent GBuffer data
		FGBufferData AdjGBuffer = GetGBufferDataFromSceneTexturesLoad(SampleCoord);
		float AdjDeviceZ = SceneDepthTexture.Load(int3(SampleCoord, 0)).r;
		float3 AdjWorldPosition;
		float3 AdjCameraDirection;
		ReconstructTranslatedWorldPositionAndCameraDirectionFromDeviceZ(SampleCoord, AdjDeviceZ, AdjWorldPosition, AdjCameraDirection);


		// TODO: refine sample rejection tests
		if (dot(GBuffer.WorldNormal, AdjGBuffer.WorldNormal) < SpatialNormalRejectionThreshold)
		{
			continue;
		}

		if (abs(GBuffer.Depth - AdjGBuffer.Depth) / GBuffer.Depth > SpatialDepthRejectionThreshold)
		{
			continue;
		}

		if (GBuffer.ShadingModelID != AdjGBuffer.ShadingModelID)
		{
			continue;
		}
		uint2 samplePosID = clamp(floor(SampleCoord / float(UpscaleFactor) ), uint2(0,0), ReservoirBufferDim.xy - 1);
		RTXGI_Reservoir neighborSample = RTXGI_Reservoir::Load(ReadReservoirData(samplePosID, InputSlice));

		// Load that neighbor's RIS state, do resampling
		if (neighborSample.sampleRef.IsValid())
		{			
			//ToDo - does this need to be a permutation?
			bool Visible = true;
#if (VISIBILITY_BEFORE_COMBINE)
			if (ApplyApproximateVisibilityTest)
			{
				Visible = CheckApproximateVisibility(SampleCoord, DeviceZ, WorldPosition, GBuffer, neighborSample.sampleRef);
			}
#endif
			float3 OffsetB = neighborSample.sampleRef.Position - neighborSample.sampleRef.CreationPoint;
			float3 OffsetA = neighborSample.sampleRef.Position - WorldPosition;
			// Discard back-face
			if (dot(WorldNormal, OffsetA) < 0 || any(isnan(OffsetA)) || any(isnan(OffsetB)))
			{
				continue;
			}

			//float pOldTN = GetTargetPdf(neighborSample.sampleRef.Irradiance, neighborSample.sampleRef.CreationNormal, neighborSample.sampleRef.CreationPoint, GatherSampleTNear.Position);
			float pNewTN = GetTargetPdf(neighborSample.sampleRef.Irradiance, WorldNormal, WorldPosition, neighborSample.sampleRef.Position);

			float RB2 = dot(OffsetB, OffsetB);
			float RA2 = dot(OffsetA, OffsetA);
			OffsetB = normalize(OffsetB);
			OffsetA = normalize(OffsetA);

			float cosA = dot(WorldNormal, OffsetB);
			float cosB = dot(neighborSample.sampleRef.CreationNormal, OffsetB);
			float cosPhiA = -dot(OffsetA, neighborSample.sampleRef.Normal);
			float cosPhiB = -dot(OffsetB, neighborSample.sampleRef.Normal);
			// Discard extreme samples to prevent fireflies
			if ( cosPhiB <= 0 || RA2 <= 0 || RB2 <= 0)
			{
				continue;
			}
			float Jocbian = RB2 * max(0.0,cosPhiA) / max(1e-5, (RA2 * cosPhiB));

			float neighborWeight = Visible ? Jocbian * pNewTN  : 0;
			{
				cachedResult |= (1u << uint(i));
				if (state.CombineReservoirs(neighborSample, RandContext.GenerateSample1D(), neighborWeight))
				{
					selected = i;
					selectedPos = neighborSample.sampleRef.Position;
					selectedNormal = neighborSample.sampleRef.Normal;
				}
			}
		}
	}

	if (state.sampleRef.IsValid())
	{
#if (!SPATIAL_RESTIR_BIAS)
		{
			// Compute the unbiased normalization term (instead of using 1/M)
			float pi = state.targetPdf;
			float piSum = state.targetPdf * centerSample.M;

			// To do this, we need to walk our neighbors again
			for (int i = 0; i < NumSamples; ++i)
			{
				// If we skipped this neighbor above, do so again.
				if ((cachedResult & (1u << uint(i))) == 0) continue;

				// Handle the rare cases when there is no sample
				if (selected == -1) continue;

#if !USE_LDS_FOR_SPATIAL_RESAMPLE
				int2 SampleCoord = SamplePoints[i];
#else
				float2 Offset = NeighborOffsets[(StartIdx + i) & NeighborOffsetMask] * 2.0f - 1.0f;
				int2 SampleCoord = round(float2(PixelCoord) + (Offset * SpatialSamplingRadius));
#endif

				FGBufferData AdjGBuffer = GetGBufferDataFromSceneTexturesLoad(SampleCoord);
				float AdjDeviceZ = SceneDepthTexture.Load(int3(SampleCoord, 0)).r;
				float3 AdjWorldPosition;
				float3 AdjCameraDirection;
				ReconstructTranslatedWorldPositionAndCameraDirectionFromDeviceZ(SampleCoord, AdjDeviceZ, AdjWorldPosition, AdjCameraDirection);

				// Get the PDF of the sample RIS selected in the first loop, above, *at this neighbor* 
				float ps = GetApproximateLightSampleWeight(AdjWorldPosition, AdjCameraDirection, AdjGBuffer, state.sampleRef);
#if 1 
				//ToDo - does this need to be a permutation?
				if (ApplyApproximateVisibilityTest && ps > 0)
				{
					//bool Visible = CheckApproximateVisibility(PixelCoord, DeviceZ, AdjWorldPosition, AdjGBuffer, state.sampleRef);
					bool Visible = CheckApproximateVisibility(SampleCoord, AdjDeviceZ, AdjWorldPosition, AdjGBuffer, state.sampleRef);

					if (!Visible)
					{
						ps = 0;
					}
				}
#endif
				uint2 sampleID = uint2(SampleCoord / float(UpscaleFactor) + 0.5);
				if( any(sampleID > DispatchRaysDimensions().xy) )
					continue;
				RTXGI_Reservoir neighborSample = RTXGI_Reservoir::Load(ReadReservoirData(sampleID, InputSlice));

				// Select this sample for the (normalization) numerator if this particular neighbor pixel
				//     was the one we selected via RIS in the first loop, above.
				pi = selected == i ? ps : pi;

				// Add to the sums of weights for the (normalization) denominator
				piSum += ps * neighborSample.M;
			}

			// Use "MIS-like" normalization
			state.FinalizeResampling(pi, piSum);
		}
#else
		{
			state.FinalizeResampling(1.0, state.M);
		}
#endif

	}
}

RAY_TRACING_ENTRY_RAYGEN(ApplySpatialResamplingRGS)
{
	uint2 DispatchThreadId = DispatchRaysIndex().xy + View.ViewRectMin.xy;
	uint2 PixelCoord = GetPixelCoord(DispatchThreadId, UpscaleFactor);
	if (any(PixelCoord >= View.ViewSizeAndInvSize.xy))
	{
		return;
	}

	uint LinearIndex = CalcLinearIndex(PixelCoord);
	FRandomContext RandContext = FRandomContext::Create(LinearIndex, View.StateFrameIndex + HistoryReservoir * 32);

	FGBufferData GBuffer = GetGBufferDataFromSceneTexturesLoad(PixelCoord);
	float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;
	float3 WorldPosition;
	float3 CameraDirection;
	ReconstructTranslatedWorldPositionAndCameraDirectionFromDeviceZ(PixelCoord, DeviceZ, WorldPosition, CameraDirection);


	RTXGI_Reservoir state = RTXGI_Reservoir::Empty();
	float3 DiffuseColor = GBuffer.DiffuseColor;
	const bool bIsDepthValid = DeviceZ > 0.0;
	const bool bIsValidPixel = GBuffer.ShadingModelID != SHADINGMODELID_UNLIT && bIsDepthValid && Luminance(DiffuseColor) > DiffuseThreshold;

	if (bIsValidPixel)
	{
		ApplySpatialResampling(PixelCoord, DispatchThreadId,GBuffer, DeviceZ, WorldPosition, CameraDirection, RandContext, state);
	}
	
	WriteReservoirData(DispatchThreadId, OutputSlice, state.Store());
}