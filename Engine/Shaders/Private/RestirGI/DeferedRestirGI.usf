#if USE_DEFERED_GI

#define RAY_TRACING_DEFERRED_GI_SHADER_VERSION 0xC1669BC2  // Change to force shader compilation of this shader

// EDeferredMaterialMode
#define DEFERRED_MATERIAL_MODE_NONE   0
#define DEFERRED_MATERIAL_MODE_GATHER 1
#define DEFERRED_MATERIAL_MODE_SHADE  2

#ifndef DIM_DEFERRED_MATERIAL_MODE
	#define DIM_DEFERRED_MATERIAL_MODE DEFERRED_MATERIAL_MODE_NONE
#endif

#ifndef DIM_GENERATE_RAYS
	#define DIM_GENERATE_RAYS 0
#endif

#endif

#define USE_IES_TERM 0 // this shader doesn't bind the IES atlas, so disable the IES term from path tracer lights
#include "../Common.ush"

#ifndef VISIBILITY_BEFORE_COMBINE
#define VISIBILITY_BEFORE_COMBINE 1
#endif

#ifndef MAX_SPATIAL_SAMPLES
#define MAX_SPATIAL_SAMPLES		16
#endif

#ifndef USE_LDS_FOR_SPATIAL_RESAMPLE
#define USE_LDS_FOR_SPATIAL_RESAMPLE	1
#endif

#define USE_SOURCE_TEXTURE_ARRAY	1

#define SUPPORT_CONTACT_SHADOWS		0
#define USE_SOURCE_TEXTURE_ARRAY	1

#include "../RectLight.ush"
//#include "../MonteCarlo.ush"
#include "../DeferredShadingCommon.ush"
#include "../ShadingModels.ush"
#include "../SceneTextureParameters.ush"
#include "../RayTracing/RayTracingCommon.ush"
#include "../RayTracing/RayTracingDeferredShadingCommon.ush"
#include "../RayTracing/RayTracingHitGroupCommon.ush"

#include "../PathTracing/Material/PathTracingMaterialSampling.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"

// #define EXPLORE_DISTANCE_TYPE
#define LIGHT_GRID 1
#define LIGHT_TREE 2
#define LIGHT_CUT  3
#define LIGHT_UNIFROM 4

// #define LIGHT_SAMPLING_TYPE 2

#ifndef LIGHT_SAMPLING_TYPE
#define LIGHT_SAMPLING_TYPE 0
#endif

#if LIGHT_SAMPLING_TYPE == LIGHT_UNIFROM
#define UNIFORM_LIGHT_SELECTION
#endif
#if LIGHT_SAMPLING_TYPE == LIGHT_GRID
#define USE_PATH_TRACING_LIGHT_GRID 1
#else
#define USE_PATH_TRACING_LIGHT_GRID 0
#endif

#if TRACE_STEP
#include "../PathTracing/Light/PathTracingLightGrid.ush"

#if LIGHT_SAMPLING_TYPE > LIGHT_GRID
#define MESH_LIGHT_SAMPLING     1
#include "../LightCut/LightTreeSampling.ush"
#endif

#endif
#include "../PathTracing/Light/PathTracingLightSampling.ush"

#include "ReservoirManagement.ush"
#include "RandomNumberUtils.ush"

#if USE_DEFERED_GI
#include "../RayTracing/RayTracingDeferredMaterials.ush"
#include "../RayTracing/RayTracingGICommon.ush"

uint2 RayTracingResolution;
uint2 TileAlignedResolution;
float TextureMipBias;

// Buffer of ray intersections aquired during Gather phase and 
// used during to reduce ray intersection overhead during Shading.
RWStructuredBuffer<FSortedGIRay>                RayBuffer;
RWStructuredBuffer<FDeferredMaterialPayload>    MaterialBuffer;
RWStructuredBuffer<FRayIntersectionBookmark>    BookmarkBuffer;

RWTexture2D<float4> RWDebugDiffuseUAV;
// #define 	USE_SCREEN_GI_REPROJECTION 1
Texture2D	ReprojectedHistory;

#endif


#define USE_PATHTRACING_MATERIALS 0

RaytracingAccelerationStructure TLAS;
RWTexture2D<float2> RWGlobalIlluminationRayDistanceUAV;

Texture2D<float> DepthHistory;
Texture2D<float4> NormalHistory;

Texture2D		SSAOTex;

float MaxNormalBias;
int InputSlice;
int OutputSlice;
int NumReservoirs;
int HistoryReservoir;
int InitialCandidates;
float SpatialSamplingRadius;
int SpatialSamples;
int SpatialSamplesBoost;
int MaxTemporalHistory;
int ApplyApproximateVisibilityTest;
int DemodulateMaterials;
uint UpscaleFactor;
float LongPathRatio;

float MaxRayDistanceForGI;
float MaxRayDistanceForAO;
float MaxShadowDistance;
uint MaxBounces;
float DiffuseThreshold;
uint EvalSkyLight;
uint UseRussianRoulette;
uint UseFireflySuppression;
float NextEventEstimationSamples;

int SupportTranslucency;

int VisibilityApproximateTestMode;
int VisibilityFaceCull;
int FeedbackVisibility;

float SpatialDepthRejectionThreshold;
float SpatialNormalRejectionThreshold;
float TemporalDepthRejectionThreshold;
float TemporalNormalRejectionThreshold;

uint NeighborOffsetMask;
Buffer<float2> NeighborOffsets;

#if TRACE_STEP
#if MESH_LIGHT_SAMPLING  
//lightcut common
int DistanceType;
int MaxCutNodes;
int CutShareGroupSize;
float ErrorLimit;
int UseApproximateCosineBound;
int InterleaveRate;
//mesh light cut
StructuredBuffer<int> MeshLightCutBuffer;
StructuredBuffer<FLightNode> MeshLightNodesBuffer;
int 						 MeshLightLeafStartIndex;

//mesh light param
StructuredBuffer<float3>       MeshLightVertexBuffer;
StructuredBuffer<uint>         MeshLightIndexBuffer;
StructuredBuffer<MeshLightInstanceTriangle>    MeshLightInstancePrimitiveBuffer;
StructuredBuffer<MeshLightInstance>   MeshLightInstanceBuffer;
uint 							NumLightTriangles;
#endif

#endif

#if USE_SURFEL
#include "../SurfelGI/SurfelCommon.ush"
RWByteAddressBuffer SurfelMetaBuf;
RWByteAddressBuffer SurfelGridMetaBuf;

RWStructuredBuffer<uint> SurfelLifeBuf;
RWStructuredBuffer<uint> SurfelPoolBuf;
RWStructuredBuffer<SurfelVertexPacked> SurfelRePositionBuf;
RWStructuredBuffer<uint> SurfelRePositionCountBuf;
RWStructuredBuffer<SurfelVertexPacked> SurfelVertexBuf;
RWStructuredBuffer<float4> SurfelIrradianceBuf;
RWStructuredBuffer<uint> SurfelEntryCellBuf;

#include "../SurfelGI/SurfelLookUp.ush"
#endif

// #define USE_RADIANCE_CACHE	0
// #if USE_RADIANCE_CACHE
// #include "../WRC/ProbeLookup.ush"
// #endif

#if MESH_LIGHT_SAMPLING  
bool SampleTriangleLight(float2 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	int triId,
	float PickPdf,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{

	OutDirection = 0;
	OutDistance = 0;
	OutRadianceOverPdf = 0;

	MeshLightInstanceTriangle prim = MeshLightInstancePrimitiveBuffer[triId];
    const float4x4 transform = MeshLightInstanceBuffer[prim.InstanceID].Transform;

	// const uint v0 = MeshLightIndexBuffer[triId * 3];
	// const uint v1 = MeshLightIndexBuffer[triId * 3 + 1];
	// const uint v2 = MeshLightIndexBuffer[triId * 3 + 2];
	uint v0 = MeshLightIndexBuffer[prim.IndexOffset];
	uint v1 = MeshLightIndexBuffer[prim.IndexOffset + 1];
	uint v2 = MeshLightIndexBuffer[prim.IndexOffset + 2];

	const float3 p0 = mul(float4(MeshLightVertexBuffer[v0],1.0f), transform).xyz;
	const float3 p1 = mul(float4(MeshLightVertexBuffer[v1],1.0f), transform).xyz;
	const float3 p2 = mul(float4(MeshLightVertexBuffer[v2],1.0f), transform).xyz;
	
	float3  Emission = MeshLightInstanceBuffer[prim.InstanceID].Emission;

	float3 LightN = cross(p2 - p0,p1 - p0);
	float Area = 0.5 * length(LightN);
	
	//sample a point in triangle
	float e1 = RandSample.x;
	float e2 = RandSample.y;
	float beta = e2 * sqrt(1 - e1);
	float gamma = 1 - sqrt(1 - e1);

	float3 SampleLightPos = p0 + beta * (p1 - p0) + gamma * (p2 - p0);

	float3 Direction = (SampleLightPos - WorldPos);
	float dSquared = max(dot(Direction, Direction), 1e-1) ;
	float LightDist = sqrt(dSquared);
	Direction /= LightDist;
	// Direction = normalize(Direction);
	// float LightDist = length(Direction);

	float dDotn = abs(dot(-Direction, normalize(LightN))) + 1e-4;
	//float Pdf = dSquared;
	//if( Area > 1e-4)
	float Pdf = dSquared / (Area * dDotn );
	//if( Pdf <= 0) return false;
	OutDirection = Direction;
	OutDistance =  LightDist - 8e-1;
	OutPdf = Pdf * PickPdf;
	OutRadianceOverPdf = Emission / OutPdf;

	return true;
}

bool SampleMeshLight(float3 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	int NodeID,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	if( NumLightTriangles == 0)
		return false;
#if LIGHT_SAMPLING_TYPE == LIGHT_UNIFROM
	// pick a triangle
	int triId = min(int(floor(RandSample.x * NumLightTriangles)), NumLightTriangles - 1);
	float LightPickPdf = 1.0 / NumLightTriangles;
#elif LIGHT_SAMPLING_TYPE == LIGHT_TREE
	float LightPickPdf = 1.0;
	int triId = 0;
	bool deadBranch = TraverseLightTree(WorldPos, WorldNormal, 1, MeshLightNodesBuffer, 
				MeshLightLeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x,LightPickPdf,triId);
	if( deadBranch ) return false;
#else
	float LightPickPdf = 1.0;
	int triId = 0;
	bool deadBranch = TraverseLightTree(WorldPos, WorldNormal, NodeID, MeshLightNodesBuffer, 
				MeshLightLeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x,LightPickPdf,triId);
	if( deadBranch ) return false;
#endif
	return SampleTriangleLight(
		RandSample.yz,
		WorldPos,
		WorldNormal,
		triId,
		LightPickPdf,
		OutDirection,
		OutDistance,
		OutRadianceOverPdf,
		OutPdf
	);

}
#endif

#if USE_DEFERED_GI

bool ShouldTraceRay(uint2 DispatchThreadId, FGBufferData GBufferData)
{
	bool bTraceRay = true;

	// Cull based on shading model
	uint ShadingModelID = GBufferData.ShadingModelID;
	if (ShadingModelID == SHADINGMODELID_UNLIT)
	{
		bTraceRay = false;
	}

	// Cull based on diffuse threshold
	float3 DiffuseColor = GBufferData.DiffuseColor;
	if (Luminance(DiffuseColor) < DiffuseThreshold)
	{
		bTraceRay = false;
	}

	// Cull based on ViewRect
	if (any(DispatchThreadId - View.ViewRectMin.xy >= RayTracingResolution))
	{
		bTraceRay = false;
	}

	return bTraceRay;
}

#endif

//Extended trace types to support miss shader evaluation of light functions
struct FLightFunctionPayload : FMinimalPayload
{
	float Attenuation;
};

uint2 GetPixelCoord2(uint2 DispatchThreadId, uint UpscaleFactor)
{
	uint UpscaleFactorPow2 = UpscaleFactor * UpscaleFactor;

	// TODO(Denoiser): find a way to not interfer with TAA's jittering.
	//uint SubPixelId = View.StateFrameIndex & (UpscaleFactorPow2 - 1);

	return DispatchThreadId * UpscaleFactor;// + uint2(SubPixelId & (UpscaleFactor - 1), SubPixelId / UpscaleFactor);
}

void TraceLightFunctionRayPacked(
	inout FPackedMaterialClosestHitPayload PackedPayload,
	in RaytracingAccelerationStructure TLAS,
	in uint RayFlags,
	in uint InstanceInclusionMask,
	in uint2 PixelCoord,
	in RayDesc Ray)
{
	const uint RayContributionToHitGroupIndex = RAY_TRACING_SHADER_SLOT_SHADOW;
	const uint MultiplierForGeometryContributionToShaderIndex = RAY_TRACING_NUM_SHADER_SLOTS;
	const uint MissShaderIndex = 0;

	// By enabling minimal payload mode all other payload information is ignored, meaning these functions need no payload inputs
	PackedPayload.SetMinimalPayloadMode();
	PackedPayload.HitT = 0;
	PackedPayload.SetPixelCoord(PixelCoord);

	// Trace the ray
	TraceRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		RayContributionToHitGroupIndex,
		MultiplierForGeometryContributionToShaderIndex,
		MissShaderIndex,
		Ray,
		PackedPayload);
}

FLightFunctionPayload TraceLightFunctionRay(
	in RaytracingAccelerationStructure TLAS,
	in uint RayFlags,
	in uint InstanceInclusionMask,
	in uint2 PixelCoord,
	in RayDesc Ray)
{
	FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload)0;

	if (!SupportTranslucency)
	{
		PackedPayload.SetIgnoreTranslucentMaterials();
	}

	TraceLightFunctionRayPacked(PackedPayload, TLAS, RayFlags, InstanceInclusionMask, PixelCoord, Ray);


	FLightFunctionPayload LightFunctionPayload = (FLightFunctionPayload)0;

	LightFunctionPayload.HitT = PackedPayload.HitT;

	return LightFunctionPayload;
}


float GetApproximateLightSampleWeight(float3 WorldPosition, float3 CameraDirection, FGBufferData GBuffer, RTXGI_SampleRef SampleRef)
{
	// float3 dir = normalize(SampleRef.Position - WorldPosition);
	// float cosTheta = dot(dir, GBuffer.WorldNormal);
	// float weight = Luminance(GBuffer.DiffuseColor * SampleRef.Li * cosTheta);
	float weight = GetTargetPdf(SampleRef.Irradiance,GBuffer.WorldNormal, WorldPosition,  SampleRef.Position);
	return weight;
}

bool CheckApproximateVisibility(uint2 PixelCoord, float DeviceZ, float3 WorldPosition, FGBufferData GBuffer, RTXGI_SampleRef SampleRef)
{
	RayDesc Ray;

	Ray.Origin = WorldPosition;
	float3 toLight = SampleRef.Position - WorldPosition;
	float length = sqrt(dot( toLight, toLight));
	Ray.Direction = toLight / length;
	
	Ray.TMin = 0.0;
	Ray.TMax = max(0.01, length - 5e-2);

	// ToDo - respect the transmissive flag on lights
	float NoL = dot(GBuffer.WorldNormal, Ray.Direction);
	if (NoL > 0.0)
	{
		// ApplyCameraRelativeDepthBias(Ray, PixelCoord, DeviceZ, GBuffer.WorldNormal, MaxNormalBias);
		ApplyPositionBias(Ray, GBuffer.WorldNormal, MaxNormalBias);
	}
	else
	{
		ApplyPositionBias(Ray, -GBuffer.WorldNormal, MaxNormalBias);
	}

	uint RayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;
	RayFlags |= VisibilityFaceCull == 1 ? RAY_FLAG_CULL_FRONT_FACING_TRIANGLES : 0;
	RayFlags |= VisibilityFaceCull == 2 ? RAY_FLAG_CULL_BACK_FACING_TRIANGLES : 0;
	RayFlags |= VisibilityApproximateTestMode == 1 ? RAY_FLAG_FORCE_OPAQUE : 0;
	RayFlags |= VisibilityApproximateTestMode == 2 ? RAY_FLAG_CULL_NON_OPAQUE : 0;
	const uint InstanceInclusionMask = RAY_TRACING_MASK_SHADOW;


	FMinimalPayload MinimalPayload = TraceVisibilityRay(
		TLAS,
		RayFlags,
		InstanceInclusionMask,
		PixelCoord,
		Ray);

	return !MinimalPayload.IsHit();
}

#if USE_DEFERED_GI
void ProduceInitialSampleForDeferedGI(uint2 PixelCoord,FSortedGIRay GIRay,uint PixelRayIndex,uint2 SvPosition, FGBufferData GBufferData, inout FRandomContext RandContext, inout RTXGI_Reservoir state)
{
	RTXGI_Reservoir LocalReservoir = RTXGI_Reservoir::Empty();
	float3 WorldPosition = GIRay.Origin;
    float RayPdf = GIRay.Pdf;
    float3 Irradiance = 0;
	const uint SampleCount = 1;
    float HitDistance = 0.0;
	float HitCount = 0.0;
#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
	// uint2 BufferSize = View.BufferSizeAndInvSize.xy;
	uint2 BufferSize = ceil(View.BufferSizeAndInvSize.xy / UpscaleFactor);
	uint2 Pixel = PixelCoord;
	// uint2 Pixel = PixelCoord;
	int startAddr =  MAX_CUT_NODES * ( (Pixel.y / CutShareGroupSize) * ((BufferSize.x + CutShareGroupSize - 1) / CutShareGroupSize) + Pixel.x / CutShareGroupSize );

	uint numPass = ceil(float(MaxCutNodes) / (InterleaveRate * InterleaveRate));
#endif
    UNROLL
	for(uint SampleIndex = 0; SampleIndex < 1; SampleIndex++)
	{
		RTXGI_SampleRef sampleRef;
		RayDesc Ray;
		Ray.TMin = 0.01;
		Ray.TMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
		Ray.Origin    = GIRay.Origin;
		Ray.Direction = GIRay.GetDirection();

		RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, SvPosition, SampleIndex, View.StateFrameIndex, SampleCount);

#if MESH_LIGHT_SAMPLING
	#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
		float factor = 1.0 ;
		for(uint NeeTrial = 0; NeeTrial < numPass; ++NeeTrial)
	#else
		float factor = 1.0 / NextEventEstimationSamples;
		for (uint NeeTrial = 0; NeeTrial < NextEventEstimationSamples; ++NeeTrial)
	#endif
		{
			float3 LightRadianceOverPdf = 0;
			float NeePdf = 0.0;

			float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
			RayDesc LightRay;
			int NodeID = 1;
		#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			if( CutShareGroupSize > 0)
			{
				int cutNodeId = NeeTrial;

				int startId = 0;
				int endId = MaxCutNodes;

				if (InterleaveRate > 1)
				{
					int interleaveGroupSize = InterleaveRate * InterleaveRate;
					int interleaveSamplingId = ( View.StateFrameIndex + InterleaveRate * (Pixel.y % InterleaveRate) + (Pixel.x % InterleaveRate)) % interleaveGroupSize;

					float ratio = float(MaxCutNodes) / interleaveGroupSize;
					startId = int(interleaveSamplingId * ratio);  
					endId = interleaveSamplingId == interleaveGroupSize - 1 ? MaxCutNodes : int((interleaveSamplingId + 1) * ratio);

					if (startId + NeeTrial >= endId) break;
					else
					{
						cutNodeId = startId + NeeTrial;
					}
				}
				else
				{
					if (cutNodeId >= MaxCutNodes) break;
				}
				int cutID = cutNodeId + startAddr;
				NodeID = MeshLightCutBuffer[cutID];
				if (NodeID < 0) break;
			}
		#endif
			if( SampleMeshLight(RandSample3,
						Ray.Origin,
						GBufferData.WorldNormal,
						NodeID,
						LightRay.Direction,
						LightRay.TMax,
						LightRadianceOverPdf,
						NeePdf) )
			{
		#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			LightRadianceOverPdf *= ( InterleaveRate * InterleaveRate);
		#endif
				LightRay.Origin = Ray.Origin;
				LightRay.TMin = 0;
				LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
				bool bTransmission = true;
				float3 BiasNormal = GBufferData.WorldNormal;
				if ( dot(BiasNormal, LightRay.Direction) < 0.0)
				{
					BiasNormal = -BiasNormal;
				}
				ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

				// Trace visibility ray
				uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
				const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
				NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

				FMinimalPayload NeePayload = TraceVisibilityRay(
					TLAS,
					NeeRayFlags,
					NeeInstanceInclusionMask,
					PixelCoord,
					LightRay);

				// No hit indicates successful next-event connection
				if (NeePayload.IsMiss())
				{
					// Evaluate material
					float3 MaterialThroughput;
					half3 N = GBufferData.WorldNormal;
					half3 V = -Ray.Direction;
					half3 L = LightRay.Direction;
					float NoL = saturate(dot(N, L));
					FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
					FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
					MaterialThroughput = LightingSample.Diffuse;
					if (bTransmission)
					{
						MaterialThroughput += LightingSample.Transmission;
					}

					// Record the contribution
	
					float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput * factor;
					// float3 ExitantRadianceSample = float3(1,0,0);
					// Tonemap for firefly suppression
					if (UseFireflySuppression)
					{
						ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
					}

					Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
				}
			}
		}
#endif //MESH_LIGHT_SAMPLING
		float3 RayThroughput = 1.0;
		float3 RandSample = RandomSequence_GenerateSample1D(RandSequence);
		RayThroughput *= Diffuse_Lambert(GBufferData.DiffuseColor) * saturate(dot(GBufferData.WorldNormal, Ray.Direction)) / GBufferData.DiffuseColor ;
		
		if (UseRussianRoulette)
		{
			float RRSample = RandSample.x;
			float ProbabilityOfSuccess = Luminance(GBufferData.DiffuseColor);
			float ProbabilityOfTermination = 1.0 - ProbabilityOfSuccess;
			if (RRSample < ProbabilityOfTermination) continue;
			RayThroughput /= ProbabilityOfSuccess;
		}

// #if USE_RADIANCE_CACHE
// 		FarRadianceFieldQuery FieldQuery = FarRadianceFieldQuery::FromRay(Ray.Origin, Ray.Direction);
//         FieldQuery.QueryNormal = GBufferData.WorldNormal;
//         FieldQuery.InterpolationURand = RandomSequence_GenerateSample3D(RandSequence);
//         FarRadianceField Field = FieldQuery.Query();
//         if (Field.IsHit()) 
//         {
//             Ray.TMax = Field.ProbeHitT;
//         }
// #endif

		FRayIntersectionBookmark Bookmark = BookmarkBuffer[PixelRayIndex];
		uint RayFlags = 0;
		const uint InstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;
		const bool bEnableSkyLightContribution = true;
		const bool bIgnoreTranslucentMaterials = false;
		
	#if !ENABLE_TWO_SIDED_GEOMETRY
		RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
	#endif

		FPackedMaterialClosestHitPayload PackedPayload = (FPackedMaterialClosestHitPayload)0;
		if (bEnableSkyLightContribution)
		{
			PackedPayload.SetEnableSkyLightContribution();
		}
		PackedPayload.SetPixelCoord(SvPosition);
		PackedPayload.SetMipBias(TextureMipBias);
		
		TraceDeferredMaterialShadingRay(
			TLAS,
			RayFlags,
			InstanceInclusionMask,
			Ray,
			Bookmark,
			PackedPayload);

		//Unpack the payload
		FMaterialClosestHitPayload Payload = UnpackRayTracingPayload(PackedPayload, Ray);

		// Environment hit
		if (Payload.IsMiss())
		{
		// #if USE_RADIANCE_CACHE
		// 	if (Field.IsHit()) 
        //     {
        //         Irradiance += Field.Radiance * Field.InvPdf;
		// 		// RWDebugDiffuseUAV[PixelCoord] = float4(Irradiance, 1.0);
		// 	}
		// 	else 
		// #endif
			{
				// Optional multi-bounce SkyLight contribution
				if (EvalSkyLight )
				{
					uint SkyLightId = 0;
					RayDesc LightRay = Ray;
					LightRay.TMax = POSITIVE_INFINITY;
					float3 EnvironmentRadiance = SkyLight_TraceLight(Ray, SkyLightId).Radiance;
					Irradiance += EnvironmentRadiance / RayPdf;
				}
			}
			break;
		}

		if (Payload.HitT > MaxRayDistanceForGI)
			break;
        // Update intersection
		Ray.Origin += Ray.Direction * Payload.HitT;
		{
            HitDistance += Payload.HitT;
			HitCount += 1.0;

            sampleRef.CreationPoint = WorldPosition - LWCHackToFloat(PrimaryView.PreViewTranslation);
            sampleRef.CreationNormal = GBufferData.WorldNormal;
            sampleRef.Position = Ray.Origin - LWCHackToFloat(PrimaryView.PreViewTranslation);
            sampleRef.Normal = Payload.WorldNormal;
		}

		// Create faux GBuffer to use with EvaluateBxDF
		FGBufferData GBufferData = (FGBufferData)0;
		GBufferData.Depth = 1.f; // Do not use depth
		GBufferData.WorldNormal = Payload.WorldNormal;
		GBufferData.BaseColor = Payload.BaseColor;
		GBufferData.CustomData = Payload.CustomData;
		GBufferData.GBufferAO = Payload.GBufferAO;
		GBufferData.IndirectIrradiance = (Payload.IndirectIrradiance.x + Payload.IndirectIrradiance.y + Payload.IndirectIrradiance.z) / 3.f;
		GBufferData.SpecularColor = Payload.SpecularColor;
		GBufferData.DiffuseColor = Payload.DiffuseColor;
		GBufferData.Metallic = Payload.Metallic;
		GBufferData.Specular = Payload.Specular;
		GBufferData.Roughness = Payload.Roughness;
		GBufferData.ShadingModelID = Payload.ShadingModelID;
		GBufferData.CustomData = Payload.CustomData;


		//TODO: use mesh light explict sampling
		// if (AccumulateEmissive)
		// {
		// 	Irradiance += Payload.Radiance;
		// }
		float3 Position = Ray.Origin;
		float3 Normal = Payload.WorldNormal;
// #if USE_SCREEN_GI_REPROJECTION
// 		// float4 RayHitClipPos =  mul( float4( Position, 1 ), View.WorldToClip );
// 		// RayHitClipPos.xyz *= rcp(RayHitClipPos.w);
// 		// float2 RayHitUV = (RayHitClipPos.xy * float2(1, -1) + 1) * 0.5;
// 		// uint2 HitPixelCoord = RayHitUV * View.ViewSizeAndInvSize.xy + View.ViewRectMin.xy;
// 		// float HitScreenDepth = SceneDepthTexture.Load(int3(HitPixelCoord, 0)).r;
// 		// bool IsOnScreen = true && all(abs(RayHitClipPos.xy) < 1.0)
//         //     && abs((RayHitClipPos.z - HitScreenDepth) / RayHitClipPos.z) < 0.1;

// 		float4 RayHitClipPos = mul(float4(Position, 1), View.WorldToClip);
// 		float3 RayHitScreenPos = RayHitClipPos.xyz / RayHitClipPos.w;
// 		float2 RayHitUV = RayHitScreenPos.xy * View.ScreenPositionScaleBias.xy + View.ScreenPositionScaleBias.wz;
// 		uint2 HitPixelCoord = RayHitUV * View.ViewSizeAndInvSize.xy + View.ViewRectMin.xy;
// 		float HitScreenDepth = SceneDepthTexture.Load(int3(HitPixelCoord, 0)).r;
// 		bool IsOnScreen = true && all(abs(RayHitUV.xy) < 1.0)
//              && abs((RayHitScreenPos.z - HitScreenDepth) / RayHitScreenPos.z) < 0.1;
//         // If it is on-screen, we'll try to use its reprojected radiance from the previous frame
//         float4 ProjectedRadiance = 0;
//         if (IsOnScreen) 
// 		{
//             // ProjectedRadiance = ReprojectedHistory.SampleLevel(LinearSampler, HitUV, 0);
// 			ProjectedRadiance = ReprojectedHistory[HitPixelCoord];
//             // Check if the temporal reprojection is valid.
//             IsOnScreen = ProjectedRadiance.w > 0;
//         }

// 		if( IsOnScreen )
// 		{
// 			Irradiance += ProjectedRadiance.xyz  / View.PreExposure;
// 			//RWDebugDiffuseUAV[PixelCoord] = float4(ProjectedRadiance.xyz, 1.0);
// 		}
// 		else
// #endif
		{
#if !MESH_LIGHT_SAMPLING
			Irradiance += Payload.Radiance * RayThroughput / RayPdf;
#else
	#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			for(uint NeeID = 0; NeeID < numPass; ++NeeID)
	#else
			for (uint NeeID = 0; NeeID < NextEventEstimationSamples; ++NeeID)
	#endif
			{
				float3 LightRadianceOverPdf = 0;
				float NeePdf = 0.0;

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
				RayDesc LightRay;
				int nodeID = 1;
			#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
				if( CutShareGroupSize > 0)
				{
					int cutNodeId = NeeID;

					int startId = 0;
					int endId = MaxCutNodes;

					if (InterleaveRate > 1)
					{
						int interleaveGroupSize = InterleaveRate * InterleaveRate;
						int interleaveSamplingId = ( View.StateFrameIndex + InterleaveRate * (Pixel.y % InterleaveRate) + (Pixel.x % InterleaveRate)) % interleaveGroupSize;

						float ratio = float(MaxCutNodes) / interleaveGroupSize;
						startId = int(interleaveSamplingId * ratio);  
						endId = interleaveSamplingId == interleaveGroupSize - 1 ? MaxCutNodes : int((interleaveSamplingId + 1) * ratio);

						if (startId + NeeID >= endId) break;
						else
						{
							cutNodeId = startId + NeeID;
						}
					}
					else
					{
						if (cutNodeId >= MaxCutNodes) break;
					}
					int cutID = cutNodeId + startAddr;
					nodeID = MeshLightCutBuffer[cutID];
					if (nodeID < 0) break;
				}
			#endif
				if( SampleMeshLight(RandSample3,
							Ray.Origin,
							Payload.WorldNormal,
							nodeID,
							LightRay.Direction,
							LightRay.TMax,
							LightRadianceOverPdf,
							NeePdf) )
				{
		#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
			LightRadianceOverPdf *= ( InterleaveRate * InterleaveRate);
		#endif
					LightRay.Origin = Ray.Origin;
					LightRay.TMin = 0;
					LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
					bool bTransmission = true;
					float3 BiasNormal = Payload.WorldNormal;
					if ( dot(BiasNormal, LightRay.Direction) < 0.0)
					{
						BiasNormal = -BiasNormal;
					}
					ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

					// Trace visibility ray
					uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
					const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

	#if !ENABLE_TWO_SIDED_GEOMETRY
					NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
	#endif

					FMinimalPayload NeePayload = TraceVisibilityRay(
						TLAS,
						NeeRayFlags,
						NeeInstanceInclusionMask,
						PixelCoord,
						LightRay);

					// No hit indicates successful next-event connection
					if (NeePayload.IsMiss())
					{
						// Evaluate material
						float3 MaterialThroughput;
	#if USE_PATHTRACING_MATERIALS
						FMaterialEval MaterialEval = EvalMaterial(CameraDirection, LightRay.Direction, Payload, false);
						MaterialThroughput = MaterialEval.Weight * MaterialEval.Pdf;
	#else
						half3 N = Payload.WorldNormal;
						half3 V = -Ray.Direction;
						half3 L = LightRay.Direction;
						float NoL = saturate(dot(N, L));
						FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
						FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
						MaterialThroughput = LightingSample.Diffuse;
						if (bTransmission)
						{
							MaterialThroughput += LightingSample.Transmission;
						}
	#endif

						// Record the contribution
						float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput* RayThroughput * factor / RayPdf;
						// float3 ExitantRadianceSample = float3(1,0,0);
						// Tonemap for firefly suppression
						if (UseFireflySuppression)
						{
							ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
						}

						Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
					}
				}
			}
#endif //MESH_LIGHT_SAMPLING
		}

		{
			// Perform next-event estimation
			float SplitFactor = 1.0 / NextEventEstimationSamples;
			for (uint NeeTrial = 0; NeeTrial < NextEventEstimationSamples; ++NeeTrial)
			{
				// Light selection
				int LightId;
				float3 LightRadianceOverPdf = 0;
				float NeePdf = 0.0;

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);

				RayDesc LightRay;
				if (SampleLight(RandSample3,
								Position,
								Normal,
								Payload.PrimitiveLightingChannelMask,
								ENABLE_TRANSMISSION,
								LightId,
								LightRay.Direction,
								LightRay.TMax,
								LightRadianceOverPdf,
								NeePdf))
				{
					LightRay.Origin = Position;
					LightRay.TMin = 0;
					LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
					bool bTransmission = HasTransmission(LightId);
					float3 BiasNormal = Payload.WorldNormal;
					if (bTransmission && dot(BiasNormal, LightRay.Direction) < 0.0)
					{
						BiasNormal = -BiasNormal;
					}
					ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

					// Trace visibility ray
					uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
					const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

		#if !ENABLE_TWO_SIDED_GEOMETRY
					NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
		#endif

					FMinimalPayload NeePayload = TraceVisibilityRay(
						TLAS,
						NeeRayFlags,
						NeeInstanceInclusionMask,
						SvPosition,
						LightRay);

					// No hit indicates successful next-event connection
					if (NeePayload.IsMiss())
					{
						// Evaluate material
						half3 N = Payload.WorldNormal;
						half3 V = -Ray.Direction;
						half3 L = LightRay.Direction;
						float NoL = saturate(dot(N, L));
						FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
						FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
						float3 MaterialThroughput = LightingSample.Diffuse;
						if (bTransmission)
						{
							MaterialThroughput += LightingSample.Transmission;
						}

						// Record the contribution
						float3 ExitantRadianceSample = RayThroughput * LightRadianceOverPdf * MaterialThroughput * SplitFactor / RayPdf;
						Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
					}
				}
			}
		}
#if USE_SURFEL
		float3 SurfeLighting =  GBufferData.DiffuseColor * GetSurfelGI(Ray.Origin, GBufferData.WorldNormal, 0, RandSequence);
		Irradiance += SurfeLighting;
		RWDebugDiffuseUAV[PixelCoord] = float4(SurfeLighting,1.0);
#endif

		sampleRef.Irradiance = Irradiance;
		float targetPdf = GetTargetPdf(sampleRef.Irradiance, sampleRef.CreationPoint,sampleRef.CreationNormal, sampleRef.Position);	
		float invSourcePdf = 1.0;
		float risRnd = RandContext.GenerateSample1D();

		LocalReservoir.StreamSample(sampleRef, risRnd, targetPdf, invSourcePdf);
	}
	LocalReservoir.FinalizeResampling(1.0, LocalReservoir.M);
	LocalReservoir.M = 1;
	state = LocalReservoir;
    if (HitCount > 0.0)
	{
		HitDistance /= HitCount;
	}
	else
	{
		HitDistance = -1.0;
	}
	RWGlobalIlluminationRayDistanceUAV[PixelCoord] = float2(HitDistance, 1.0);
}

/***************************************************************************************************
 *
 *  GenerateInitialSamplesForDeferedGI
 *
 ***************************************************************************************************/
RAY_TRACING_ENTRY_RAYGEN(GenerateInitialSamplesForDeferedGIRGS)
{
	const uint DispatchThreadId = DispatchRaysIndex().x; // This shader is dispatched in 1D configuration

	FDeferredMaterialPayload DeferredMaterialPayload = (FDeferredMaterialPayload)0;
	DeferredMaterialPayload.SortKey = RAY_TRACING_DEFERRED_MATERIAL_KEY_INVALID;

#if DIM_DEFERRED_MATERIAL_MODE == DEFERRED_MATERIAL_MODE_GATHER

	FSortedGIRay GIRay;

	{
		const uint  ThreadGroupSize  = GI_RAY_DIRECTION_SORT_TILE_SIZE * GI_RAY_DIRECTION_SORT_TILE_SIZE;
		const uint2 TileSize         = uint2(GI_RAY_DIRECTION_SORT_TILE_SIZE, GI_RAY_DIRECTION_SORT_TILE_SIZE);
		const uint  TileIndex        = DispatchThreadId / ThreadGroupSize;
		const uint  RayIndexInTile   = DispatchThreadId % ThreadGroupSize;
		const uint2 NumTiles         = TileAlignedResolution / TileSize;
		const uint2 TileBasePixelPos = uint2(TileIndex % NumTiles.x, TileIndex / NumTiles.x) * TileSize;
		const uint2 PixelPos         = View.ViewRectMin.xy + TileBasePixelPos + uint2(RayIndexInTile % TileSize.x, RayIndexInTile / TileSize.x);

		GIRay = GenerateDeferredGIRay(PixelPos, UpscaleFactor, MaxNormalBias);
        RayBuffer[DispatchThreadId] = GIRay; // Store the ray to be used in shading phase
	}	

	DeferredMaterialPayload.PixelCoordinates = DispatchThreadId; // Store the sorted ray index, not packed 2D pixel coordinates
	const uint2 PixelCoord = UnpackPixelCoordinates(GIRay.PixelCoordinates);

    if (all(PixelCoord - View.ViewRectMin.xy < RayTracingResolution))
	{
        uint2 SvPosition = GetPixelCoord(PixelCoord, UpscaleFactor);
        float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
        float2 UV = (float2(SvPosition) + 0.5) * InvBufferSize;

        //#dxr-todo: workaround for flickering. UE-87281
        FGBufferData GBufferData = GetGBufferDataFromSceneTexturesLoad(SvPosition);

        // Remap DiffuseColor when using SubsurfaceProfile (GBuffer decoding replaces with 100% albedo)
        if (UseSubsurfaceProfile(GBufferData.ShadingModelID))
        {
            GBufferData.DiffuseColor = GBufferData.StoredBaseColor;
        }
        bool bShouldTrace = ShouldTraceRay(PixelCoord,GBufferData );
        if ( bShouldTrace )
        {
            RayDesc Ray;
            Ray.TMin = 0.01;
            Ray.TMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
            Ray.Origin    = GIRay.Origin;
            Ray.Direction = GIRay.GetDirection();

            DeferredMaterialPayload.SortKey = RAY_TRACING_DEFERRED_MATERIAL_KEY_RAY_MISS;
            FRayIntersectionBookmark Bookmark = (FRayIntersectionBookmark)0;

            uint RayFlags = 0;
    #if !ENABLE_TWO_SIDED_GEOMETRY
            RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
    #endif

            TraceDeferredMaterialGatherRay(TLAS,
                RayFlags,
                RAY_TRACING_MASK_OPAQUE,
                Ray,
                Bookmark,
                DeferredMaterialPayload
            );
            BookmarkBuffer[DispatchThreadId] = Bookmark;
        }
	}

	MaterialBuffer[DispatchThreadId] = DeferredMaterialPayload;
#elif DIM_DEFERRED_MATERIAL_MODE == DEFERRED_MATERIAL_MODE_SHADE
	    
    DeferredMaterialPayload = MaterialBuffer[DispatchThreadId];

	// Linear ray index is stored in PixelCoordinates (see DEFERRED_MATERIAL_MODE_GATHER above)
	const uint GIRayIndex = DeferredMaterialPayload.PixelCoordinates;

	FSortedGIRay GIRay = RayBuffer[GIRayIndex];
	const uint2 PixelCoord = UnpackPixelCoordinates(GIRay.PixelCoordinates);
    uint2 SvPosition = GetPixelCoord(PixelCoord, UpscaleFactor);
    float2 InvBufferSize = View.BufferSizeAndInvSize.zw;
    float2 UV = (float2(SvPosition) + 0.5) * InvBufferSize;
    // RWDebugDiffuseUAV[PixelCoord] = 0.0;

	uint LinearIndex = CalcLinearIndex(SvPosition);
	FRandomContext RandContext = FRandomContext::Create(LinearIndex, View.StateFrameIndex + HistoryReservoir * 32);

    //#dxr-todo: workaround for flickering. UE-87281
    FGBufferData GBufferData = GetGBufferDataFromSceneTexturesLoad(SvPosition);

    // Remap DiffuseColor when using SubsurfaceProfile (GBuffer decoding replaces with 100% albedo)
    if (UseSubsurfaceProfile(GBufferData.ShadingModelID))
    {
        GBufferData.DiffuseColor = GBufferData.StoredBaseColor;
    }
	RTXGI_Reservoir state = RTXGI_Reservoir::Empty();
	bool bTraceRay = ShouldTraceRay(PixelCoord, GBufferData);

	if (bTraceRay)
	{
		ProduceInitialSampleForDeferedGI( PixelCoord,GIRay, GIRayIndex,SvPosition ,GBufferData,  RandContext, state);
	}
	WriteReservoirData(PixelCoord, OutputSlice, state.Store());
    RWDebugDiffuseUAV[PixelCoord] = float4(state.sampleRef.Irradiance,1.0);
#endif
}

#endif
