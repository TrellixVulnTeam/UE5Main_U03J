#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"
#include "../PositionReconstructionCommon.ush" 

#include "HashUtils.ush"
#include "RandomUtils.ush"
#include "SphereHarmonic.ush"
#include "PackUtils.ush"
#include "Reservoir.ush"
#include "SurfelConstant.ush"
#include "SurfelSampler.ush"

StructuredBuffer<uint> SurfelLifeBuf;
RWByteAddressBuffer SurfelMetaBuf;
RWStructuredBuffer<float4> SurfelIrradianceBuf;
RWStructuredBuffer<float4> SurfelAuxiBuf;
StructuredBuffer<uint> SurfelEntryIndirectionBuf;

struct Contribution {
    float4 sh_rgb[3];

    void add_radiance_in_direction(float3 radiance, float3 direction) {
        // https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/gdc2018-precomputedgiobalilluminationinfrostbite.pdf
        // `shEvaluateL1`, plus the `4` factor, with `pi` cancelled out in the evaluation code (BRDF).
        float4 sh = float4(0.282095, direction * 0.488603) * 4;
        sh_rgb[0] += sh * radiance.r;
        sh_rgb[1] += sh * radiance.g;
        sh_rgb[2] += sh * radiance.b;
    }

    void scale(float value) {
        sh_rgb[0] *= value;
        sh_rgb[1] *= value;
        sh_rgb[2] *= value;
    }
};

[numthreads(64, 1, 1)]
void SumIrradianceCS(uint dispatch_idx: SV_DispatchThreadID) {
    if (IRCACHE_FREEZE) {
        return;
    }

    const uint total_alloc_count = SurfelMetaBuf.Load(IRCACHE_META_TRACING_ALLOC_COUNT);
    if (dispatch_idx >= total_alloc_count) {
        return;
    }

    const uint entry_idx = SurfelEntryIndirectionBuf[dispatch_idx];
    const uint output_idx = entry_idx * IRCACHE_IRRADIANCE_STRIDE;

    Contribution contribution_sum = (Contribution)0;
    {
        float valid_samples = 0;

        // TODO: counter distortion
        for (uint octa_idx = 0; octa_idx < IRCACHE_OCTA_DIMS2; ++octa_idx) {
            const float2 octa_coord = (float2(octa_idx % IRCACHE_OCTA_DIMS, octa_idx / IRCACHE_OCTA_DIMS) + 0.5) / IRCACHE_OCTA_DIMS;

            const Reservoir1spp r = Reservoir1spp::from_raw(asuint(SurfelAuxiBuf[entry_idx * IRCACHE_AUX_STRIDE + octa_idx].xy));
            const float3 dir = SampleParams::from_raw(r.payload).direction();

            const float4 contrib = SurfelAuxiBuf[entry_idx * IRCACHE_AUX_STRIDE + IRCACHE_OCTA_DIMS2 + octa_idx];

            contribution_sum.add_radiance_in_direction(
                contrib.rgb * contrib.w,
                dir
            );

            valid_samples += contrib.w > 0 ? 1.0 : 0.0;
        }

        contribution_sum.scale(1.0 / max(1.0, valid_samples));
    }

    for (uint basis_i = 0; basis_i < IRCACHE_IRRADIANCE_STRIDE; ++basis_i) {
        const float4 new_value = contribution_sum.sh_rgb[basis_i];
        float4 prev_value =
            SurfelIrradianceBuf[entry_idx * IRCACHE_IRRADIANCE_STRIDE + basis_i];
            //* frame_constants.pre_exposure_delta;

        const bool should_reset = all(0.0 == prev_value);
        if (should_reset) {
            prev_value = new_value;
        }

        float blend_factor_new = 0.25;
        //float blend_factor_new = 1;
        const float4 blended_value = lerp(prev_value, new_value, blend_factor_new);

        SurfelIrradianceBuf[entry_idx * IRCACHE_IRRADIANCE_STRIDE + basis_i] = blended_value;
    }
}
