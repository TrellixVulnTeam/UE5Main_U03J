

#include "/Engine/Public/Platform.ush"
#include "HashUtils.ush"
#include "PackUtils.ush"
#include "SurfelConstant.ush"
#include "SurfelGrid.ush"
ByteAddressBuffer SurfelGridMetaBuf;
RWByteAddressBuffer SurfelGridMetaBuf2;
RWStructuredBuffer<uint> SurfelEntryCellBuf;
RWStructuredBuffer<float4> SurfelIrradianceBuf;
RWStructuredBuffer<uint> SurfelLifeBuf;
RWStructuredBuffer<uint> SurfelPoolBuf;
RWByteAddressBuffer SurfelMetaBuf;


void deallocate_cell(uint cell_idx) {
    const uint2 meta = SurfelGridMetaBuf.Load2(sizeof(uint2) * cell_idx);

    if (meta.y & IRCACHE_ENTRY_META_OCCUPIED) {
        // Clear the just-nuked entry
        const uint entry_idx = meta.x;

        SurfelLifeBuf[entry_idx] = IRCACHE_ENTRY_LIFE_RECYCLED;

        for (uint i = 0; i < IRCACHE_IRRADIANCE_STRIDE; ++i) {
            SurfelIrradianceBuf[entry_idx * IRCACHE_IRRADIANCE_STRIDE + i] = 0.0.xxxx;
        }

        uint entry_alloc_count = 0;
        SurfelMetaBuf.InterlockedAdd(IRCACHE_META_ALLOC_COUNT, -1, entry_alloc_count);
        SurfelPoolBuf[entry_alloc_count - 1] = entry_idx;
    }
}

// Note: group dims must be divisors of IRCACHE_CASCADE_SIZE
[numthreads(32, 1, 1)]
void ScrollCascadeCS(uint3 dispatch_thread_id: SV_DispatchThreadID) {
    const uint3 dst_vx = uint3(dispatch_thread_id.xy, dispatch_thread_id.z % IRCACHE_CASCADE_SIZE);
    const uint cascade = dispatch_thread_id.z / IRCACHE_CASCADE_SIZE;

    const uint dst_cell_idx = IrcacheCoord::from_coord_cascade(dst_vx, cascade).cell_idx();

    const int3 scroll_by =
        IRCACHE_FREEZE
        ? (0).xxx
        : SurfelGridVoxelScrolled[cascade].xyz;

    if (!all(uint3(dst_vx - scroll_by) < IRCACHE_CASCADE_SIZE)) {
        // If this entry is about to get overwritten, deallocate it.
        deallocate_cell(dst_cell_idx);
    }

    const uint3 src_vx = dst_vx + scroll_by;

    if (all(src_vx < IRCACHE_CASCADE_SIZE)) {
        const uint src_cell_idx = IrcacheCoord::from_coord_cascade(src_vx, cascade).cell_idx();

        const uint2 cell_meta = SurfelGridMetaBuf.Load2(sizeof(uint2) * src_cell_idx);
        SurfelGridMetaBuf2.Store2(sizeof(uint2) * dst_cell_idx, cell_meta);

        // Update the cell idx in the `SurfelEntryCellBuf`
        if (cell_meta.y & IRCACHE_ENTRY_META_OCCUPIED) {
            const uint entry_idx = cell_meta.x;
            SurfelEntryCellBuf[entry_idx] = dst_cell_idx;
        }
    } else {
        SurfelGridMetaBuf2.Store2(sizeof(uint2) * dst_cell_idx, (0).xx);
    }
}
