#pragma once

#include "../Common.ush"
#include "RayTracingCommon.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#define GI_RAY_DIRECTION_SORT_TILE_SIZE 32

struct FSortedGIRay
{
	float3	Origin;
	uint	PixelCoordinates;
	
	uint2   DirectionPacked; // fp16
	float   Pdf;

	float3 GetDirection()
	{
		float3 Result;
		Result.x = f16tof32(DirectionPacked.x & 0xFFFF);
		Result.y = f16tof32(DirectionPacked.x >> 16);
		Result.z = f16tof32(DirectionPacked.y);
		return Result;
	}

	void SetDirection(float3 Direction)
	{
		uint X = f32tof16(Direction.x);
		uint Y = f32tof16(Direction.y);
		uint Z = f32tof16(Direction.z);
		DirectionPacked.x = X | (Y << 16);
		DirectionPacked.y = Z;
	}
};

uint PackPixelCoordinates(uint2 PixelCoordinates)
{
	return (PixelCoordinates.x & 0xFFFF)
	     | (PixelCoordinates.y << 16);
}

uint2 UnpackPixelCoordinates(uint PixelCoordinates)
{
	return uint2(
		PixelCoordinates & 0xFFFF,
		PixelCoordinates >> 16);
}

void GenerateRay(
	float3 WorldNormal,
	float2 RandSample,
	out float3 RayDirection,
	out float RayPdf
)
{
#define COSINE_SAMPLING 0
#if COSINE_SAMPLING
	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
#else
	float4 Direction_Tangent = UniformSampleHemisphere(RandSample);
#endif
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayDirection = Direction_World;
	RayPdf = Direction_Tangent.w;
}

FSortedGIRay GenerateDeferredGIRay(uint2 PixelPos, uint UpscaleFactor, float GIMaxNormalBias)
{

	// float2 SvPosition = floor(float2(PixelPos) * UpscaleFactor);
	float2 SvPosition = GetPixelCoord(PixelPos, UpscaleFactor);
	const float2 BufferUV = (SvPosition + 0.5) * View.BufferSizeAndInvSize.zw;

    // not 'const', may need to be modified below
	FGBufferData GBuffer         = GetGBufferDataFromSceneTextures(BufferUV);
	float DeviceZ                = SampleDeviceZFromSceneTextures(BufferUV);

	float3 WorldPosition;
	float3 CameraDirection;
	ReconstructTranslatedWorldPositionAndCameraDirectionFromDeviceZ(SvPosition, DeviceZ, WorldPosition, CameraDirection);

	float3 V = -CameraDirection;

	RandomSequence RandSequence;
	RandomSequence_Initialize(RandSequence, SvPosition, 0, View.StateFrameIndex, 1);
	float2 RandSample = RandomSequence_GenerateSample2D(RandSequence);

	// float2 RandSample = Rand1SPPDenoiserInput(PixelPos);
	float3 WorldNormal = GBuffer.WorldNormal;

	float3 Direction_World; float RayPdf = 1.0;
	GenerateRay(WorldNormal, RandSample, Direction_World, RayPdf);
	// RayTMin = 0.01;
	// RayPdf = Direction_Tangent.w;

	FSortedGIRay Ray = (FSortedGIRay)0;
	Ray.PixelCoordinates = PackPixelCoordinates(PixelPos);

	Ray.Origin = WorldPosition;
	Ray.SetDirection(Direction_World);
	Ray.Pdf = RayPdf;

	ApplyCameraRelativeDepthBias(Ray.Origin, Direction_World, SvPosition, DeviceZ, WorldNormal, GIMaxNormalBias);


	return Ray;
}