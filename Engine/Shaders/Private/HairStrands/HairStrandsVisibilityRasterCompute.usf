// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "HairStrandsClusterCommon.ush"
#include "HairStrandsVertexFactoryCommon.ush"
#include "HairStrandsVisibilityCommon.ush"

///////////////////////////////////////////////////////////////////////////
// 
// Wave size
#if SHADER_RASTERCOMPUTE_DEPTH_GRID == 0

#if PERMUTATION_GROUP_SIZE == 64
#define WAVE_SIZE 32
#elif PERMUTATION_GROUP_SIZE == 32
#define WAVE_SIZE 32
#else
#error Unknown group size	
#endif

#endif //SHADER_RASTERCOMPUTE_DEPTH_GRID

///////////////////////////////////////////////////////////////////////////

uint TileSize;
float RcpTileSize;
uint SqrTileSize;

uint NumBinners;
float RcpNumBinners;
uint NumRasterizers;
float RcpNumRasterizers;

/* 
// use untyped buffer for segment tiles to reduce VGPR usage - 16 bytes
struct FVisTile
{
	uint PrimOffset;
	uint PrimCount;
	uint TileCoord;
	uint MinDepth;
};
*/
#define VT_SIZE 4

#define VT_PrimOffset 0
#define VT_PrimCount 1
#define VT_Coord 2
#define VT_NearestDepth 3

uint PackVisTileCoord(uint2 Coord)
{
	return uint(((Coord.x & 0xff) << 0) | (((Coord.y) & 0xff) << 8));
}

uint2 UppackVisTileCoord(uint Packed)
{
	return uint2(((Packed >> 0) & 0xff), ((Packed >> 8) & 0xff));
}

///////////////////////////////////////////////////////////////////////////

uint			MaxRasterCount;
uint			FrameIdMod8;
uint			MacroGroupId;
uint			ResolutionMultiplier;
int2			OutputResolution;
float2			OutputResolutionf;
uint			HairMaterialId;
uint			HairStrandsVF_bIsCullingEnable;
float			HairStrandsVF_Radius;
float			HairStrandsVF_RootScale;
float			HairStrandsVF_TipScale;
float			HairStrandsVF_Length;
float			HairStrandsVF_Density;
uint			HairStrandsVF_bUseStableRasterization;
float3			HairStrandsVF_PositionOffset;
uint			HairStrandsVF_VertexCount;
float4x4		HairStrandsVF_LocalToWorldPrimitiveTransform;
Buffer<uint4>	HairStrandsVF_PositionBuffer;
Buffer<float4>	HairStrandsVF_PositionOffsetBuffer;

Texture2D<float> SceneDepthTexture;
float			TileLODScale;
int2			TileRes;
float			TileBaseDepth;

float3 NDCToPixelCoord(float4 InDC)
{
	const float3 NDC = InDC.xyz / InDC.w;
	float2 UV = NDC.xy * ResolvedView.ScreenPositionScaleBias.xy + ResolvedView.ScreenPositionScaleBias.wz;
	return float3(UV * OutputResolution, NDC.z);
}

void CalcScreenPos(in uint4 PB, in float3 PBO, out float3 SP, out uint Type)
{
	const FHairControlPoint CP = UnpackHairControlPoint(
		PB,
		PBO,
		HairStrandsVF_Radius,
		HairStrandsVF_RootScale,
		HairStrandsVF_TipScale);

	const float3 WP = mul(float4(CP.Position, 1), HairStrandsVF_LocalToWorldPrimitiveTransform).xyz;
	float4 NDC = mul(float4(WP, 1), LWCHackToFloat(PrimaryView.WorldToClip));

	SP = NDCToPixelCoord(NDC);

	Type = CP.Type;
}

void CalcScreenPosAndRad(in uint4 PB, in float3 PBO, out float4 SP, out float Rad)
{
	const FHairControlPoint CP = UnpackHairControlPoint(
		PB,
		PBO,
		HairStrandsVF_Radius,
		HairStrandsVF_RootScale,
		HairStrandsVF_TipScale);

	const float3 WP = mul(float4(CP.Position, 1), HairStrandsVF_LocalToWorldPrimitiveTransform).xyz;
	float4 NDC = mul(float4(WP, 1), LWCHackToFloat(PrimaryView.WorldToClip));

	SP = float4(NDCToPixelCoord(NDC).xy, NDC.zw);

	Rad = CP.WorldRadius * OutputResolutionf.x;
}

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_DEPTH_GRID

RWTexture2D<uint>	OutVisTileDepthGrid;
RWTexture2D<uint>	OutDepthCovTexture;

groupshared uint group_FurthestDepth; // (4 bytes)

[numthreads(1024, 1, 1)]
void PrepareDepthGridCS(uint dId : SV_DispatchThreadID, uint GroupThreadID : SV_GroupThreadID)
{
	uint tw = TileRes.x;
	uint th = TileRes.y;

	if (GroupThreadID == 0) group_FurthestDepth = 0xffffffff;

	GroupMemoryBarrierWithGroupSync();

	uint t = dId / 1024;

	uint ty = uint((float(t)+0.5) / float(tw));
	uint tx = t - (ty*tw);

	for (uint p = GroupThreadID; p < SqrTileSize; p += 1024)
	{
		if (p < SqrTileSize)
		{
			uint py = (float(p)+0.5) * RcpTileSize;
			uint px = p - (py*TileSize);

			uint2 Coord = uint2(tx * TileSize + px, ty * TileSize + py);

			if (Coord.x < uint(OutputResolution.x) && Coord.y < uint(OutputResolution.y))
			{
				float Depth = SceneDepthTexture.Load(uint3(Coord, 0));
				uint packedDepth = PackHairVisDepthCoverage(Depth, 1.0);

				InterlockedMin(group_FurthestDepth, packedDepth);

				InterlockedMax(OutDepthCovTexture[Coord], packedDepth);
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	OutVisTileDepthGrid[uint2(tx, ty)] = group_FurthestDepth;
}

#endif //SHADER_RASTERCOMPUTE_DEPTH_GRID

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_BINNING

#if PERMUTATION_CULLING
Buffer<uint>	HairStrandsVF_CullingIndirectBuffer;
Buffer<uint>	HairStrandsVF_CullingIndexBuffer;
Buffer<float>	HairStrandsVF_CullingRadiusScaleBuffer;
Buffer<uint>	IndirectBufferArgs;
#endif

RWTexture3D<uint> 					OutVisTileBinningGrid;
Texture2D<uint>						VisTileDepthGrid;
RWBuffer<uint>						OutVisTilePrims;
RWBuffer<uint>						OutVisTileArgs;
RWByteAddressBuffer					OutVisTileData;

uint LoadOutVisTileData(uint index, uint offset)
{
	return OutVisTileData.Load((((index)) * VT_SIZE * 4) + ((offset) * 4));
}

void StoreOutVisTileData(uint index, uint offset, uint value)
{
	OutVisTileData.Store((((index)) * VT_SIZE * 4) + ((offset) * 4), (value));
}

groupshared uint group_LoopNum;
groupshared uint group_BatchNum;

// The total number of line segments (VertexCount) is divided up equally between N binners - each binner = a workgroup which loops through the designated set segments in batches of 1024
// NB there is still potential to use LDS to prevent/reduce contention when adding segments to the binning grid and this may improve perf

[numthreads(1024, 1, 1)]
void BinningCS(uint2 DispatchThreadID : SV_DispatchThreadID, uint GroupThreadID : SV_GroupThreadID, uint GroupID : SV_GroupID)
{
	ResolvedView = ResolveView();
	if (GroupThreadID == 0)
	{
		uint VertexCount = HairStrandsVF_VertexCount;
#if PERMUTATION_CULLING	
		if (HairStrandsVF_bIsCullingEnable)
		{
			VertexCount = HairStrandsVF_CullingIndirectBuffer[3];
		}
#endif
		group_BatchNum = (VertexCount+1023)/1024;
		group_LoopNum = (group_BatchNum + (NumBinners - 1)) * RcpNumBinners;
	}

	GroupMemoryBarrierWithGroupSync();

	[loop]
	for (uint LoopIndex = 0; LoopIndex < group_LoopNum; LoopIndex++)
	{
		uint BatchIndex = LoopIndex + (GroupID * group_LoopNum);

		bool bSegValid = (BatchIndex < group_BatchNum) ? true : false;

		bool bTileIntersected[3] = { false, false, false };

		int2 TileCoord[3] = { int2(-1, -1), int2(-1, -1), int2(-1, -1) };

		uint SegIndex[3] = { 0xffffffff, 0xffffffff, 0xffffffff };

		uint PrimID = BatchIndex * 1024 + GroupThreadID;

#if PERMUTATION_CULLING
		if (bSegValid && HairStrandsVF_bIsCullingEnable)
		{
			const uint VertexCountAfterCulling = HairStrandsVF_CullingIndirectBuffer[3];
			uint FetchIndex0 = PrimID;
			if (FetchIndex0 >= (VertexCountAfterCulling-1))
			{
				bSegValid = false;
			}
			else
			{
				uint FetchIndex1 = min(FetchIndex0 + 1, VertexCountAfterCulling - 1);

				uint VertexIndex0 = HairStrandsVF_CullingIndexBuffer[FetchIndex0];
				float LodRadiusScale0 = HairStrandsVF_CullingRadiusScaleBuffer[FetchIndex0];

				uint VertexIndex1 = HairStrandsVF_CullingIndexBuffer[FetchIndex1];
				float LodRadiusScale1 = HairStrandsVF_CullingRadiusScaleBuffer[FetchIndex1];

				if ((LodRadiusScale0 <= 0.0f) || (VertexIndex1 != VertexIndex0 + 1))
				{
					bSegValid = false;
				}
				else
				{
					PrimID = VertexIndex0;
				}
			}
		}
#endif

		uint BinID = GroupID - (uint(float(GroupID + 0.5) * RcpNumBinners)* NumBinners);
		uint BinID2 = BinID + NumBinners;

#if PERMUTATION_TEMPORAL_LAYERING
		//remap linear frame index to improve TAA result (still a bit exprimental)
		uint remapped = (View.StateFrameIndex) & 0x3;
		remapped = ((remapped & 0x1) << 1) | ((remapped & 0x2) >> 1);

		if (bSegValid) bSegValid = ((PrimID < HairStrandsVF_VertexCount) && ((PrimID & 0x3) == (remapped))) ? true : false;
#else
		if (bSegValid) bSegValid = (PrimID < HairStrandsVF_VertexCount) ? true : false;
#endif
		if (bSegValid) //currently hardcoded to a maximum of 3 tile bins - this only works corectly when segment length does not exceed TileSize - TODO: add support for N bins
		{
			float3 SP0;
			float3 SP1;

			uint Type;
			CalcScreenPos(HairStrandsVF_PositionBuffer[PrimID], HairStrandsVF_PositionOffsetBuffer[0].xyz, SP0, Type);

			bool bIsEndCV = (Type == HAIR_CONTROLPOINT_END); 

			if (!bIsEndCV)
			{
				CalcScreenPos(HairStrandsVF_PositionBuffer[PrimID + 1], HairStrandsVF_PositionOffsetBuffer[0].xyz, SP1, Type);

				uint NearestDepth = PackHairVisDepthCoverage(max(SP0.z, SP1.z), 1.0);

				TileCoord[0] = int2(SP0.x * RcpTileSize, SP0.y * RcpTileSize);

				if (all(TileCoord[0] >= 0) && all(TileCoord[0] < TileRes) && NearestDepth > VisTileDepthGrid[TileCoord[0]])
				{
					InterlockedAdd(OutVisTileBinningGrid[uint3(TileCoord[0], BinID)], 1, SegIndex[0]);
					bTileIntersected[0] = true;
				}

				TileCoord[1] = int2(SP1.x * RcpTileSize, SP1.y * RcpTileSize);

				if ( any(TileCoord[1] != TileCoord[0]) && all(TileCoord[1] >= 0) && all(TileCoord[1] < TileRes) && NearestDepth > VisTileDepthGrid[TileCoord[1]])
				{
					InterlockedAdd(OutVisTileBinningGrid[uint3(TileCoord[1], BinID)], 1, SegIndex[1]);
					bTileIntersected[1] = true;
				}

				if ((bTileIntersected[0] || bTileIntersected[1]) && all(TileCoord[1] != TileCoord[0]))
				{
					float2 MP = (TileCoord[0] + float2(0.5, 0.5) + TileCoord[1] + float2(0.5, 0.5)) * 0.5 * 32;

					float2 SPI;
					SPI.x = SP0.x + (SP1.x - SP0.x) * ((MP.y - SP0.y) / (SP1.y - SP0.y));
					SPI.y = SP0.y + (SP1.y - SP0.y) * ((MP.x - SP0.x) / (SP1.x - SP0.x));

					TileCoord[2] = int2(SPI.x * RcpTileSize, SPI.y * RcpTileSize);

					if (all(TileCoord[2] >= 0) && all(TileCoord[2] < TileRes) && NearestDepth > VisTileDepthGrid[TileCoord[2]])
					{
						InterlockedAdd(OutVisTileBinningGrid[uint3(TileCoord[2], BinID)], 1, SegIndex[2]);
						bTileIntersected[2] = true;
					}
				}
			}
		}
		
		GroupMemoryBarrierWithGroupSync();

		if (bSegValid) //add tiles if any needed - this is unlikely to happen in all batches
		{
			for (int i = 0; i < 3; i++)
			{
				if ((SegIndex[i] != 0xffffffff) && ((SegIndex[i] % 1024)==0))
				{
					uint NewTile;
					InterlockedAdd(OutVisTileArgs[0], 1, NewTile);
					
					StoreOutVisTileData(NewTile, VT_Coord, PackVisTileCoord(TileCoord[i]));
					StoreOutVisTileData(NewTile, VT_PrimOffset, NewTile * 1024);
					StoreOutVisTileData(NewTile, VT_NearestDepth, SegIndex[i]); //tmp - use this to decide if seg should go in new or prev tile.

					uint PrevTile = (OutVisTileBinningGrid[uint3(TileCoord[i], BinID2)] & 0xffff);
					
					if (SegIndex[i]>0)	StoreOutVisTileData(PrevTile, VT_PrimCount, 1024);

					OutVisTileBinningGrid[uint3(TileCoord[i], BinID2)] = (PrevTile << 16) | (NewTile & 0xffff);

				}
			}
		}

		GroupMemoryBarrierWithGroupSync();

		if (bSegValid) //now set the PrimID at the location indicated by the prev/current tile.
		{
			for (int i = 0; i < 3; i++)
			{
				if (SegIndex[i] != 0xffffffff)
				{
					uint PackedTiles = OutVisTileBinningGrid[uint3(TileCoord[i], BinID2)];
					uint CurTile = (PackedTiles & 0xffff);
					uint PrevTile = ((PackedTiles >> 16) & 0xffff);

					if (SegIndex[i] >= LoadOutVisTileData(CurTile, VT_NearestDepth))
					{
						uint PrimIndex = LoadOutVisTileData(CurTile, VT_PrimOffset) + (SegIndex[i] % 1024);
						OutVisTilePrims[PrimIndex] = PrimID;

						if ((SegIndex[i] + 1) == OutVisTileBinningGrid[uint3(TileCoord[i], BinID)])
						{
							StoreOutVisTileData(CurTile, VT_PrimCount, (SegIndex[i]==1023) ? 1024 : ((SegIndex[i] + 1) % 1024));
						}
					}
					else
					{
						uint PrimIndex = LoadOutVisTileData(PrevTile, VT_PrimOffset) + (SegIndex[i] % 1024);
						OutVisTilePrims[PrimIndex] = PrimID;
					}

					//InterlockedAdd(OutVisTileArgs[1], 1); //debug
				}
			}
		}
	}
}
#endif //SHADER_RASTERCOMPUTE_BINNING

///////////////////////////////////////////////////////////////////////////

#if SHADER_RASTERCOMPUTE_RASTER

RWTexture2D<uint> 					RWVisTileDepthGrid;
Buffer<uint> 						VisTilePrims;
Buffer<uint> 						VisTileArgs;
RWByteAddressBuffer					RWVisTileData;
Buffer<uint>						VisTileIndirect;

uint LoadRWVisTileData(uint index, uint offset)
{
	return RWVisTileData.Load((((index)) * VT_SIZE * 4) + ((offset) * 4));
}

void StoreRWVisTileData(uint index, uint offset, uint value)
{
	RWVisTileData.Store((((index)) * VT_SIZE * 4) + ((offset) * 4), (value));
}

RWTexture2D<uint> OutHairCountTexture;
RWTexture2D<uint> OutDepthCovTexture;
RWTexture2D<uint> OutPrimMatTexture;


groupshared uint4 group_SubTile[1024]; //(32 x 32 x 4 x 4 bytes = 16k bytes)

groupshared float3 group_PositionOffset;
groupshared float group_ooTileLODScale;

groupshared uint group_LoopNum;
groupshared uint group_TileNum;

groupshared uint group_ThreadsPerSeg;

#define GS_SEGS 320 //this number is limited by group shared memory

groupshared float4 group_SP0[GS_SEGS];
groupshared float4 group_SP1[GS_SEGS];
groupshared float group_Rad0[GS_SEGS];
groupshared float group_Rad1[GS_SEGS];
groupshared uint group_PrimMatID[GS_SEGS];

groupshared uint group_TileIndex;

[numthreads(1024, 1, 1)]
void RasterCS(uint DispatchThreadID : SV_DispatchThreadID, uint GroupThreadID : SV_GroupThreadID, uint GroupID : SV_GroupID)
{
	ResolvedView = ResolveView();

	if (GroupThreadID == 0)
	{
		group_TileNum = VisTileArgs[0];
		group_LoopNum = (float(group_TileNum) + float(NumRasterizers - 1))* RcpNumRasterizers;
//		group_LoopNum = (float(1024) + float(NumRasterizers - 1)) * RcpNumRasterizers;

		group_PositionOffset = HairStrandsVF_PositionOffsetBuffer[0].xyz;

		group_ooTileLODScale = 1.0;// max(min(1.0 / (TileLODScale * 25.0), 16.0), 1.0);

		/* no longer in use - keep for ref? Moving these values to group shared memory did seem to reduce VGPRs - more experimentation needed
		group_RadScale = (((HairStrandsVF_TipScale - HairStrandsVF_RootScale) * HairStrandsVF_Radius * OutputResolutionf.x) / 63.0) / 255.0;
		group_RadOffset = (HairStrandsVF_RootScale * HairStrandsVF_Radius * OutputResolutionf.x)/63.0;
		*/
	}

	GroupMemoryBarrierWithGroupSync();

	[loop]
	for (uint LoopIndex = 0; LoopIndex < group_LoopNum; LoopIndex++)
	{
		if (GroupThreadID == 0)
		{
			group_TileIndex = LoopIndex + (GroupID * group_LoopNum);
		}
		
		GroupMemoryBarrierWithGroupSync();

		bool bTileValid = (group_TileIndex < group_TileNum) ? true : false;

		uint PrimOffset = LoadRWVisTileData(group_TileIndex, VT_PrimOffset);
		uint PrimCount = LoadRWVisTileData(group_TileIndex, VT_PrimCount);

		uint PackedCoord = LoadRWVisTileData(group_TileIndex, VT_Coord);
		uint2 SubTileMin = UppackVisTileCoord(PackedCoord)*TileSize;

		uint PackedTileMin = ((SubTileMin.x & 0xffff) << 0) | ((SubTileMin.y & 0xffff) << 16);

		if (GroupThreadID == 0)
		{
			group_ThreadsPerSeg = 1;

			if (PrimCount <= 512)
				group_ThreadsPerSeg = 2;
			if (PrimCount <= 341)
				group_ThreadsPerSeg = 3;
			if (PrimCount <= 256)
				group_ThreadsPerSeg = 4;
			if (PrimCount <= 204)
				group_ThreadsPerSeg = 5;
			if (PrimCount <= 170)
				group_ThreadsPerSeg = 6;
			if (PrimCount <= 146)
				group_ThreadsPerSeg = 7;
			if (PrimCount <= 128)
				group_ThreadsPerSeg = 8;
			if (PrimCount <= 64)
				group_ThreadsPerSeg = 16;
			if (PrimCount <= 32)
				group_ThreadsPerSeg = 32;
		}
		
		GroupMemoryBarrierWithGroupSync();

		bool bThreadValid = (bTileValid && (GroupThreadID < (PrimCount*group_ThreadsPerSeg) )) ? true : false;

		uint WaveCount = ((PrimCount* group_ThreadsPerSeg) + (WAVE_SIZE-1) ) / WAVE_SIZE;
		uint WaveThreadCount = WaveCount * WAVE_SIZE;

		bool bWaveThreadValid = (bTileValid && (GroupThreadID < WaveThreadCount)) ? true : false;

		bool bUseGroupSPs = (bThreadValid && (GroupThreadID < (min(PrimCount, GS_SEGS)* group_ThreadsPerSeg) )) ? true : false;

		bool bGenGroupSPs = (bThreadValid && (GroupThreadID < (min(PrimCount, GS_SEGS)) )) ? true : false;

		if (bGenGroupSPs)
		{
			uint Prim = GroupThreadID;
			uint PrimID = VisTilePrims[PrimOffset + Prim];

			group_PrimMatID[Prim] = PackHairVisPrimitiveMaterialId(PrimID, HairMaterialId);

			CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID], group_PositionOffset, group_SP0[Prim], group_Rad0[Prim]);
			CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID+1], group_PositionOffset, group_SP1[Prim], group_Rad1[Prim]);
		}

		if (bWaveThreadValid)
		{
			for (uint LinearIndex = GroupThreadID; LinearIndex < SqrTileSize; LinearIndex += WaveThreadCount)
			{
				uint2 Coord;

				Coord.y = (float(LinearIndex) + 0.5) * RcpTileSize;
				Coord.x = LinearIndex - (Coord.y * TileSize);

				Coord += uint2(((PackedTileMin >> 0) & 0xffff), ((PackedTileMin >> 16) & 0xffff));

				group_SubTile[LinearIndex].x = OutDepthCovTexture[Coord];
				group_SubTile[LinearIndex].y = 0;
				group_SubTile[LinearIndex].z = 0;
				group_SubTile[LinearIndex].w = PackHairVisDepthCoverage(SceneDepthTexture.Load(uint3(Coord, 0)), 1.0);
			}
		}

		GroupMemoryBarrierWithGroupSync();

		if (bThreadValid)
		{
			uint Prim = uint((float(GroupThreadID)+0.5) / float(group_ThreadsPerSeg));
			uint PModTPS = GroupThreadID - (Prim * group_ThreadsPerSeg);

			uint PrimMatID;
			float4 SP0;
			float4 SP1;
			float Rad0;
			float Rad1;

			if (bUseGroupSPs)
			{
				PrimMatID = group_PrimMatID[Prim];
				SP0 = group_SP0[Prim];
				SP1 = group_SP1[Prim];
				Rad0 = group_Rad0[Prim];
				Rad1 = group_Rad1[Prim];
			}
			else
			{
				uint PrimID = VisTilePrims[PrimOffset + Prim];
				PrimMatID = PackHairVisPrimitiveMaterialId(PrimID, HairMaterialId);

				CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID], group_PositionOffset, SP0, Rad0);
				CalcScreenPosAndRad(HairStrandsVF_PositionBuffer[PrimID+1], group_PositionOffset, SP1, Rad1);
			}

			uint NumSteps = min(max(abs(SP1.x - SP0.x), abs(SP1.y - SP0.y))+1.0, TileSize);

			[loop]
			for (int J = PModTPS; J < NumSteps; J+=group_ThreadsPerSeg)
			{
				const float4 SP = lerp(SP0, SP1, J / float(NumSteps));

				const int2 SPi = int2(SP.xy)-int2(((PackedTileMin >> 0) & 0xffff), ((PackedTileMin >> 16) & 0xffff));

				if (SPi.x >= 0 && SPi.x < TileSize && SPi.y >= 0 && SPi.y < TileSize)
				{
					uint PackedDepthCov = PackHairVisDepthCoverage(SP.z / SP.w, 1.0);

					uint LinearIndex = SPi.x + SPi.y * TileSize;

					uint OldValue;
					InterlockedMax(group_SubTile[LinearIndex].x, PackedDepthCov, OldValue);
					if (PackedDepthCov > OldValue)
					{
						group_SubTile[LinearIndex].y = PrimMatID;
					}

					if (PackedDepthCov > group_SubTile[LinearIndex].w)
					{
						const float Rad = lerp(Rad0, Rad1, J / float(NumSteps)) / SP.w;

#if PERMUTATION_TEMPORAL_LAYERING
						InterlockedAdd(group_SubTile[LinearIndex].z, min(Rad, 1.0) * 1.0 * 8000.0 * group_ooTileLODScale);
#else
						InterlockedAdd(group_SubTile[LinearIndex].z, min(Rad, 1.0) * 1.0 * 1000.0 * group_ooTileLODScale);
#endif
					}
				}					
			}
		}

		GroupMemoryBarrierWithGroupSync();

		if (bWaveThreadValid) 
		{
			for (uint LinearIndex = GroupThreadID; LinearIndex < SqrTileSize; LinearIndex += WaveThreadCount)
			{
				uint2 Coord;

				Coord.y = (float(LinearIndex) + 0.5) * RcpTileSize;
				Coord.x = LinearIndex - (Coord.y * TileSize);

				Coord += uint2(((PackedTileMin >> 0) & 0xffff), ((PackedTileMin >> 16) & 0xffff));

				if (group_SubTile[LinearIndex].y != 0)
				{
					uint oldValue;
					InterlockedMax(OutDepthCovTexture[Coord], group_SubTile[LinearIndex].x, oldValue);
					if (group_SubTile[LinearIndex].x > oldValue)
					{
						OutPrimMatTexture[Coord] = group_SubTile[LinearIndex].y;
					}
				}
				InterlockedAdd(OutHairCountTexture[Coord], group_SubTile[LinearIndex].z);
			}
		}

		GroupMemoryBarrierWithGroupSync();
	}
}

#endif //SHADER_RASTERCOMPUTE_RASTER

///////////////////////////////////////////////////////////////////////////

