#ifdef PRE_DISPATCH_TRACE

ByteAddressBuffer SurfelMetaBuf;
RWByteAddressBuffer DispatchArgs;

[numthreads(1, 1, 1)]
void PreDispatchTrace() 
{
    const uint surfel_count = SurfelMetaBuf.Load(sizeof(uint) * 1);
    DispatchArgs.Store4(0, uint4(surfel_count, 1, 1, 0));
}

#endif

#ifdef SURFEL_TRACE


#define USE_IES_TERM 0 // this shader doesn't bind the IES atlas, so disable the IES term from path tracer lights
#include "../Common.ush"

#include "../RectLight.ush"
//#include "../MonteCarlo.ush"
#include "../DeferredShadingCommon.ush"
#include "../ShadingModels.ush"
#include "../SceneTextureParameters.ush"
#include "../RayTracing/RayTracingCommon.ush"

#include "../RayTracing/RayTracingDeferredShadingCommon.ush"
#include "../RayTracing/RayTracingHitGroupCommon.ush"

#define LIGHT_GRID 1
#define LIGHT_TREE 2
#define LIGHT_CUT  3
#define LIGHT_UNIFROM 4

// #define LIGHT_SAMPLING_TYPE 2

#ifndef LIGHT_SAMPLING_TYPE
#define LIGHT_SAMPLING_TYPE 1
#endif

#if LIGHT_SAMPLING_TYPE == LIGHT_UNIFROM
#define UNIFORM_LIGHT_SELECTION
#endif
#if LIGHT_SAMPLING_TYPE == LIGHT_GRID
#define USE_PATH_TRACING_LIGHT_GRID 1
#else
#define USE_PATH_TRACING_LIGHT_GRID 0
#endif

#include "../PathTracing/Material/PathTracingMaterialSampling.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "../PathTracing/Light/PathTracingLightGrid.ush"
#if LIGHT_SAMPLING_TYPE > LIGHT_GRID
#define MESH_LIGHT_SAMPLING     1
#include "../LightCut/LightTreeSampling.ush"
#endif

#include "../PathTracing/Light/PathTracingLightSampling.ush"

#include "SurfelCommon.ush"

RaytracingAccelerationStructure TLAS;


uint SamplesPerPixel;
uint MaxBounces;
uint UpscaleFactor;
float MaxRayDistanceForGI;
float MaxRayDistanceForAO;
float MaxShadowDistance;
float NextEventEstimationSamples;
float DiffuseThreshold;
uint EvalSkyLight;
uint UseRussianRoulette;
uint UseFireflySuppression;
float MaxNormalBias;
uint RenderTileOffsetX;
uint RenderTileOffsetY;
uint AccumulateEmissive;

RWByteAddressBuffer SurfelMetaBuf;
RWByteAddressBuffer SurfelGridMetaBuf;
RWStructuredBuffer<float4> SurfelAuxiBuf; //0 : prev irradiance, 1 : varaicne related variable

RWStructuredBuffer<uint> SurfelLifeBuf;
RWStructuredBuffer<uint> SurfelPoolBuf;
RWStructuredBuffer<SurfelVertexPacked> SurfelRePositionBuf;
RWStructuredBuffer<uint> SurfelRePositionCountBuf;
RWStructuredBuffer<SurfelVertexPacked> SurfelVertexBuf;
RWStructuredBuffer<float4> SurfelIrradianceBuf;
RWStructuredBuffer<uint> SurfelEntryCellBuf;

#include "SurfelLookUp.ush"

#if MESH_LIGHT_SAMPLING  
//lightcut common
int DistanceType;
int MaxCutNodes;
int CutShareGroupSize;
float ErrorLimit;
int UseApproximateCosineBound;
int InterleaveRate;
//mesh light cut
StructuredBuffer<int> MeshLightCutBuffer;
StructuredBuffer<FLightNode> MeshLightNodesBuffer;
int 						 MeshLightLeafStartIndex;

//mesh light param
StructuredBuffer<float3>       MeshLightVertexBuffer;
StructuredBuffer<uint>         MeshLightIndexBuffer;
StructuredBuffer<MeshLightInstanceTriangle>    MeshLightInstancePrimitiveBuffer;
StructuredBuffer<MeshLightInstance>   MeshLightInstanceBuffer;
uint 							NumLightTriangles;
#endif

void GenerateCosineNormalRay(
	float3 WorldPosition,
	float3 WorldNormal,
	float2 RandSample,
	out float3 RayOrigin,
	out float3 RayDirection,
	out float RayTMin,
	out float RayTMax,
	out float RayPdf
)
{
	// Perform cosine-hemispherical sampling and convert to world-space
	float4 Direction_Tangent = CosineSampleHemisphere(RandSample);
	float3 Direction_World = TangentToWorld(Direction_Tangent.xyz, WorldNormal);

	RayOrigin = WorldPosition;
	RayDirection = Direction_World;
	RayTMin = 0.01;
	RayTMax = max(MaxRayDistanceForGI, MaxRayDistanceForAO);
	RayPdf = Direction_Tangent.w;
}

#if MESH_LIGHT_SAMPLING  
bool SampleTriangleLight(float2 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	int triId,
	float PickPdf,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{

	OutDirection = 0;
	OutDistance = 0;
	OutRadianceOverPdf = 0;

	MeshLightInstanceTriangle prim = MeshLightInstancePrimitiveBuffer[triId];
    const float4x4 transform = MeshLightInstanceBuffer[prim.InstanceID].Transform;

	// const uint v0 = MeshLightIndexBuffer[triId * 3];
	// const uint v1 = MeshLightIndexBuffer[triId * 3 + 1];
	// const uint v2 = MeshLightIndexBuffer[triId * 3 + 2];
	uint v0 = MeshLightIndexBuffer[prim.IndexOffset];
	uint v1 = MeshLightIndexBuffer[prim.IndexOffset + 1];
	uint v2 = MeshLightIndexBuffer[prim.IndexOffset + 2];

	const float3 p0 = mul(float4(MeshLightVertexBuffer[v0],1.0f), transform).xyz;
	const float3 p1 = mul(float4(MeshLightVertexBuffer[v1],1.0f), transform).xyz;
	const float3 p2 = mul(float4(MeshLightVertexBuffer[v2],1.0f), transform).xyz;
	
	float3  Emission = MeshLightInstanceBuffer[prim.InstanceID].Emission;

	float3 LightN = cross(p2 - p0,p1 - p0);
	float Area = 0.5 * length(LightN);
	
	//sample a point in triangle
	float e1 = RandSample.x;
	float e2 = RandSample.y;
	float beta = e2 * sqrt(1 - e1);
	float gamma = 1 - sqrt(1 - e1);

	float3 SampleLightPos = p0 + beta * (p1 - p0) + gamma * (p2 - p0);

	float3 Direction = (SampleLightPos - WorldPos);
	float dSquared = max(dot(Direction, Direction), 1e-1) ;
	float LightDist = sqrt(dSquared);
	Direction /= LightDist;
	// Direction = normalize(Direction);
	// float LightDist = length(Direction);

	float dDotn = abs(dot(-Direction, normalize(LightN))) + 1e-4;
	//float Pdf = dSquared;
	//if( Area > 1e-4)
	float Pdf = dSquared / (Area * dDotn );
	//if( Pdf <= 0) return false;
	OutDirection = Direction;
	OutDistance =  LightDist - 8e-1;
	OutPdf = Pdf * PickPdf;
	OutRadianceOverPdf = Emission / OutPdf;

	return true;
}

bool SampleMeshLight(float3 RandSample,
	float3 WorldPos,
	float3 WorldNormal,
	int NodeID,
	out float3 OutDirection,
	out float  OutDistance,
	out float3 OutRadianceOverPdf,
	out float OutPdf)
{
	if( NumLightTriangles == 0)
		return false;
#if LIGHT_SAMPLING_TYPE == LIGHT_UNIFROM
	// pick a triangle
	int triId = min(int(floor(RandSample.x * NumLightTriangles)), NumLightTriangles - 1);
	float LightPickPdf = 1.0 / NumLightTriangles;
#elif LIGHT_SAMPLING_TYPE == LIGHT_TREE
	float LightPickPdf = 1.0;
	int triId = 0;
	bool deadBranch = TraverseLightTree(WorldPos, WorldNormal, 1, MeshLightNodesBuffer, 
				MeshLightLeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x,LightPickPdf,triId);
	if( deadBranch ) return false;
#else
	float LightPickPdf = 1.0;
	int triId = 0;
	bool deadBranch = TraverseLightTree(WorldPos, WorldNormal, NodeID, MeshLightNodesBuffer, 
				MeshLightLeafStartIndex, UseApproximateCosineBound, DistanceType,
				RandSample.x,LightPickPdf,triId);
	if( deadBranch ) return false;
#endif
	return SampleTriangleLight(
		RandSample.yz,
		WorldPos,
		WorldNormal,
		triId,
		LightPickPdf,
		OutDirection,
		OutDistance,
		OutRadianceOverPdf,
		OutPdf
	);

}
#endif

#define TARGET_SAMPLE_COUNT 128
static const uint SHORT_ESTIMATOR_SAMPLE_COUNT = 4;

RAY_TRACING_ENTRY_RAYGEN(SurfelTraceRGS)
{
	const uint SurfelIndex = DispatchRaysIndex().x;
	const uint SurfelCount = SurfelMetaBuf.Load(SURFEL_META_ENTRY_COUNT);

	const uint life = SurfelLifeBuf[SurfelIndex];

	if( SurfelIndex >= SurfelCount || !IsSurfelLifeValid(life) )
		return ;
	
	#if USE_DYNAMIC_TRACE_ORIGIN
        const SurfelVertex surfel = UnPackVertex(SurfRePositionBuf[SurfelIndex]);
    #else
        const SurfelVertex surfel = UnPackVertex(SurfelVertexBuf[SurfelIndex]);
    #endif


	uint2 PixelCoord = uint2(SurfelIndex % 2048, SurfelIndex / 2048 );
    // float4 PrevRadiancePacked = min(SurfelIrradianceBuf[SurfelIndex], TARGET_SAMPLE_COUNT);

	const float4 PrevTotalRadiancePacked = SurfelAuxiBuf[SurfelIndex * 2 + 0];


	// float3 DiffuseColor = surfel.DiffuseColor;
	// if (Luminance(DiffuseColor) < DiffuseThreshold)
	// {
	// 	return;
	// }

	// uint  SampleCount = 4;
    float  ValidSampleCount = 0;
	float3 Irradiance = 0;
	float3 Sample0Irradiance = 0.0;
#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
	// uint2 BufferSize = View.BufferSizeAndInvSize.xy;
	uint2 BufferSize = ceil(View.BufferSizeAndInvSize.xy / UpscaleFactor);
	uint2 Pixel = PixelCoord;
	// uint2 Pixel = PixelCoord;
	int startAddr =  MAX_CUT_NODES * ( (Pixel.y / CutShareGroupSize) * ((BufferSize.x + CutShareGroupSize - 1) / CutShareGroupSize) + Pixel.x / CutShareGroupSize );

	uint numPass = ceil(float(MaxCutNodes) / (InterleaveRate * InterleaveRate));
#endif

    for (uint SampleIndex = 0; SampleIndex < SamplesPerPixel; ++SampleIndex)
	{
        ValidSampleCount += 1.0;

		RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, PixelCoord, SampleIndex, View.StateFrameIndex, SamplesPerPixel);

		float3 RayThroughput = 1.0;
		float3 RandSample = RandomSequence_GenerateSample3D(RandSequence);
		
		// if (UseRussianRoulette)
		// {
		// 	float RRSample = RandSample.x;
		// 	float ProbabilityOfSuccess = Luminance(DiffuseColor);
		// 	float ProbabilityOfTermination = 1.0 - ProbabilityOfSuccess;
		// 	if (RRSample < ProbabilityOfTermination) continue;
		// 	RayThroughput /= ProbabilityOfSuccess;
		// }

    	const uint SequenceIdx = hash1(SurfelIndex) + SampleIndex + View.StateFrameIndex * SamplesPerPixel;
		const float2 Rand2 = r2_sequence(SequenceIdx % max(128, TARGET_SAMPLE_COUNT));
		
		RayDesc Ray;
		float RayPdf = 1.0;
		float3 TranslatedWorldPosition = surfel.Position + LWCHackToFloat(PrimaryView.PreViewTranslation);
		GenerateCosineNormalRay(TranslatedWorldPosition, surfel.Normal, Rand2, Ray.Origin, Ray.Direction, Ray.TMin, Ray.TMax, RayPdf);
		RayThroughput *=  saturate(dot(surfel.Normal, Ray.Direction)) / PI;
		//RayPdf = 1.0;
		
		float MaterialPdf = 0.0;
		uint Bounce = 0;
		while (Bounce < 1)
		{
			// Cast ray
			uint RayFlags = 0;
			const uint InstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;
			const bool bEnableSkyLightContribution = true;
			const bool bIgnoreTranslucentMaterials = false;

#if !ENABLE_TWO_SIDED_GEOMETRY
			RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

			FRayCone RayCone = (FRayCone)0;
			FMaterialClosestHitPayload Payload = TraceMaterialRay(
				TLAS,
				RayFlags,
				InstanceInclusionMask,
				Ray,
				RayCone,
				PixelCoord,
				bEnableSkyLightContribution,
				bIgnoreTranslucentMaterials);

			// Environment hit
			if (Payload.IsMiss())
			{
				// Optional multi-bounce SkyLight contribution
				if (EvalSkyLight )
				{
					uint SkyLightId = 0;
					RayDesc LightRay = Ray;
					LightRay.TMax = POSITIVE_INFINITY;
					float3 EnvironmentRadiance = SkyLight_TraceLight(Ray, SkyLightId).Radiance;
					Irradiance += EnvironmentRadiance * RayThroughput / RayPdf;
				}
				break;
			}

			// if (Bounce == 0)
			// {
			// }
			if (Payload.HitT > MaxRayDistanceForGI) break;

			// Update intersection
			Ray.Origin += Ray.Direction * Payload.HitT;

			// Create faux GBuffer to use with EvaluateBxDF
			FGBufferData GBufferData = (FGBufferData)0;
			GBufferData.Depth = 1.f; // Do not use depth
			GBufferData.WorldNormal = Payload.WorldNormal;
			GBufferData.BaseColor = Payload.BaseColor;
			GBufferData.CustomData = Payload.CustomData;
			GBufferData.GBufferAO = Payload.GBufferAO;
			GBufferData.IndirectIrradiance = (Payload.IndirectIrradiance.x + Payload.IndirectIrradiance.y + Payload.IndirectIrradiance.z) / 3.f;
			GBufferData.SpecularColor = Payload.SpecularColor;
			GBufferData.DiffuseColor = Payload.DiffuseColor;			
			GBufferData.Metallic = Payload.Metallic;
			GBufferData.Specular = Payload.Specular;
			GBufferData.Roughness = Payload.Roughness;
			GBufferData.ShadingModelID = Payload.ShadingModelID;
			GBufferData.CustomData = Payload.CustomData;

			{
	#if !MESH_LIGHT_SAMPLING
				Irradiance += Payload.Radiance * RayThroughput / RayPdf;
	#else
		#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
				for(uint NeeID = 0; NeeID < numPass; ++NeeID)
		#else
				for (uint NeeID = 0; NeeID < NextEventEstimationSamples; ++NeeID)
		#endif
				{
					float3 LightRadianceOverPdf = 0;
					float NeePdf = 0.0;

					float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
					RayDesc LightRay;
					int nodeID = 1;
				#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
					if( CutShareGroupSize > 0)
					{
						int cutNodeId = NeeID;

						int startId = 0;
						int endId = MaxCutNodes;

						if (InterleaveRate > 1)
						{
							int interleaveGroupSize = InterleaveRate * InterleaveRate;
							int interleaveSamplingId = ( View.StateFrameIndex + InterleaveRate * (Pixel.y % InterleaveRate) + (Pixel.x % InterleaveRate)) % interleaveGroupSize;

							float ratio = float(MaxCutNodes) / interleaveGroupSize;
							startId = int(interleaveSamplingId * ratio);  
							endId = interleaveSamplingId == interleaveGroupSize - 1 ? MaxCutNodes : int((interleaveSamplingId + 1) * ratio);

							if (startId + NeeID >= endId) break;
							else
							{
								cutNodeId = startId + NeeID;
							}
						}
						else
						{
							if (cutNodeId >= MaxCutNodes) break;
						}
						int cutID = cutNodeId + startAddr;
						nodeID = MeshLightCutBuffer[cutID];
						if (nodeID < 0) break;
					}
				#endif
					if( SampleMeshLight(RandSample3,
								Ray.Origin,
								Payload.WorldNormal,
								nodeID,
								LightRay.Direction,
								LightRay.TMax,
								LightRadianceOverPdf,
								NeePdf) )
					{
			#if LIGHT_SAMPLING_TYPE == LIGHT_CUT
				LightRadianceOverPdf *= ( InterleaveRate * InterleaveRate);
			#endif
						LightRay.Origin = Ray.Origin;
						LightRay.TMin = 0;
						LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
						bool bTransmission = true;
						float3 BiasNormal = Payload.WorldNormal;
						if ( dot(BiasNormal, LightRay.Direction) < 0.0)
						{
							BiasNormal = -BiasNormal;
						}
						ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

						// Trace visibility ray
						uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
						const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

		#if !ENABLE_TWO_SIDED_GEOMETRY
						NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
		#endif

						FMinimalPayload NeePayload = TraceVisibilityRay(
							TLAS,
							NeeRayFlags,
							NeeInstanceInclusionMask,
							PixelCoord,
							LightRay);

						// No hit indicates successful next-event connection
						if (NeePayload.IsMiss())
						{
							// Evaluate material
							float3 MaterialThroughput;
		#if USE_PATHTRACING_MATERIALS
							FMaterialEval MaterialEval = EvalMaterial(CameraDirection, LightRay.Direction, Payload, false);
							MaterialThroughput = MaterialEval.Weight * MaterialEval.Pdf;
		#else
							half3 N = Payload.WorldNormal;
							half3 V = -Ray.Direction;
							half3 L = LightRay.Direction;
							float NoL = saturate(dot(N, L));
							FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
							FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
							MaterialThroughput = LightingSample.Diffuse;
							if (bTransmission)
							{
								MaterialThroughput += LightingSample.Transmission;
							}
		#endif

							// Record the contribution
							float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput* RayThroughput * factor / RayPdf;
							// float3 ExitantRadianceSample = float3(1,0,0);
							// Tonemap for firefly suppression
							if (UseFireflySuppression)
							{
								ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
							}

							Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
						}
					}
				}
	#endif //MESH_LIGHT_SAMPLING
			}
			float SplitFactor = 1.0 / NextEventEstimationSamples;
			for (uint NeeID = 0; NeeID < NextEventEstimationSamples; ++NeeID)
			{
				// Light selection
				int LightId;
				float3 LightRadianceOverPdf = 0;
				float NeePdf = 0.0;

				float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);
				RayDesc LightRay;

				bool bLit = SampleLight(RandSample3,
						Ray.Origin,
						Payload.WorldNormal,
						Payload.PrimitiveLightingChannelMask,
						ENABLE_TRANSMISSION,
						LightId,
						LightRay.Direction,
						LightRay.TMax,
						LightRadianceOverPdf,
						NeePdf);

				if (bLit)
				{
					LightRay.Origin = Ray.Origin;
					LightRay.TMin = 0;
					LightRay.TMax = min(LightRay.TMax, MaxShadowDistance);
					bool bTransmission = HasTransmission(LightId);
					float3 BiasNormal = Payload.WorldNormal;
					if (bTransmission && dot(BiasNormal, LightRay.Direction) < 0.0)
					{
						BiasNormal = -BiasNormal;
					}
					ApplyPositionBias(LightRay, BiasNormal, MaxNormalBias);

					// Trace visibility ray
					uint NeeRayFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER;
					const uint NeeInstanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

#if !ENABLE_TWO_SIDED_GEOMETRY
					NeeRayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
#endif

					FMinimalPayload NeePayload = TraceVisibilityRay(
						TLAS,
						NeeRayFlags,
						NeeInstanceInclusionMask,
						PixelCoord,
						LightRay);

					// No hit indicates successful next-event connection
					if (NeePayload.IsMiss())
					{
						// Evaluate material
						float3 MaterialThroughput;

						half3 N = Payload.WorldNormal;
						half3 V = -Ray.Direction;
						half3 L = LightRay.Direction;
						float NoL = saturate(dot(N, L));
						FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
						FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
						MaterialThroughput = LightingSample.Diffuse;
						if (bTransmission)
						{
							MaterialThroughput += LightingSample.Transmission;
						}

						// Record the contribution
						float3 ExitantRadianceSample = LightRadianceOverPdf * MaterialThroughput * RayThroughput * SplitFactor / RayPdf;

						// Tonemap for firefly suppression
						if (UseFireflySuppression)
						{
							ExitantRadianceSample *= rcp(1.0 + Luminance(ExitantRadianceSample));
						}

						Irradiance += isfinite(ExitantRadianceSample) ? ExitantRadianceSample : 0.0;
					}
				}
			}

			// Perform material sampling
			// if (Bounce + 1 < MaxBounces)
			// {
			// 	float3 Direction;
			// 	float3 Throughput = 1.0;
			// 	float3 RandSample3 = RandomSequence_GenerateSample3D(RandSequence);

			// 	float3 RayOrigin = Ray.Origin;
			// 	GenerateCosineNormalRay(RayOrigin, Payload.WorldNormal, RandSample3.xy, Ray.Origin, Direction, Ray.TMin, Ray.TMax, MaterialPdf);
				
			// 	half3 N = Payload.WorldNormal;
			// 	half3 V = -Ray.Direction;
			// 	half3 L = Direction;
			// 	float NoL = saturate(dot(N, L));
			// 	FShadowTerms ShadowTerms = { 0.0, 0.0, 0.0, InitHairTransmittanceData() };
			// 	FDirectLighting LightingSample = EvaluateBxDF(GBufferData, N, V, L, NoL, ShadowTerms);
			// 	Throughput = LightingSample.Diffuse;
			// 	if (MaterialPdf <= 0.0)
			// 	{
			// 		break;
			// 	}

			// 	// Update ray
			// 	Ray.Direction = Direction;
			// 	RayThroughput *= Throughput;
			// 	RayPdf *= MaterialPdf;
			// }
#if USE_SURFEL
			{
                Irradiance += GetSurfelGI(Ray.Origin - LWCHackToFloat(PrimaryView.PreViewTranslation), Payload.WorldNormal, 1 + SurfelLifeToRank(life), RandSequence) * GBufferData.DiffuseColor;
            }
#endif
			Bounce++;
		}

		if( SampleIndex == 0 )
			Sample0Irradiance = Irradiance;
	}

	
	//if (SamplesPerPixel > 0)
	{
		Irradiance /= ValidSampleCount;
		// Tonemap inversion for firefly suppression
		if (UseFireflySuppression)
		{
			Irradiance *= rcp(1 - Luminance(Irradiance));
		}
	}

	const float IrradianceLum = Luminance(Irradiance);

    const float4 PrevAux = SurfelAuxiBuf[SurfelIndex * 2 + 1];
    const float PrevLuminance = PrevAux.x;
    const float2 PrevExEx2 = PrevAux.zw;

	const float2 SampleExEX2 = float2(IrradianceLum, IrradianceLum * IrradianceLum);
    const float2 BlendExEX2 = lerp(PrevExEx2, SampleExEX2, 1.0 / (1.0 + clamp(PrevTotalRadiancePacked.w, 1, SHORT_ESTIMATOR_SAMPLE_COUNT)));

    const float4 NewAux = float4(
        Luminance(Sample0Irradiance),
        lerp(PrevAux.y, IrradianceLum, 1.0 / (1.0 + clamp(PrevTotalRadiancePacked.w, 2, 2 * SHORT_ESTIMATOR_SAMPLE_COUNT))),
        BlendExEX2
    );
    SurfelAuxiBuf[SurfelIndex * 2 + 1] = NewAux;

    const float LumVariance = max(0.0, BlendExEX2.y - BlendExEX2.x * BlendExEX2.x);
    const float LumDev = sqrt(LumVariance);

    float PrevSampleCount = min(PrevTotalRadiancePacked.w, TARGET_SAMPLE_COUNT);

    const float4 prevIrradPacked = SurfelIrradianceBuf[SurfelIndex];
    const float3 PrevIrradiance = prevIrradPacked.xyz;

	//dead surfel
    if (0 == prevIrradPacked.w) 
        PrevSampleCount = 0;

    const float TotalSampleCount = PrevSampleCount + ValidSampleCount;
    float BlendFactorNew = ValidSampleCount / max(1, TotalSampleCount);

    // Forecasting mean
    const float QuickLumEx = min(BlendExEX2.x * 1.2, lerp(NewAux.y, BlendExEX2.x, 1.5));
    const float3 PrevValue = PrevTotalRadiancePacked.rgb;
    const float3 BlendValue = lerp( PrevValue, Irradiance, BlendFactorNew);

    SurfelAuxiBuf[SurfelIndex * 2 + 0] = max(0.0, float4(
        BlendValue,
        TotalSampleCount
    ));

    const float k = 0.5;

    SurfelIrradianceBuf[SurfelIndex] = max(0.0, float4(
            pow(lerp(pow(max(0.0, PrevIrradiance), k),pow(max(0.0, BlendValue), k),0.25),1.0 / k),
        TotalSampleCount
    ));

	// const float TotalSampleCount = PrevRadiancePacked.w + ValidSampleCount;
    // const float BlendFactorNew = ValidSampleCount / max(1, TotalSampleCount);

    // float3 PrevValue = PrevRadiancePacked.rgb;
	// Irradiance = ClampToHalfFloatRange(Irradiance);

    // Irradiance = lerp(PrevValue, Irradiance, BlendFactorNew);

	// SurfelIrradianceBuf[SurfelIndex] = max(0.0, float4(Irradiance,TotalSampleCount));
}

#endif