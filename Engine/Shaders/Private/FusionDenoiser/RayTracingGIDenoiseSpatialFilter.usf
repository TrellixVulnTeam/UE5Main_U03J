#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "../MonteCarlo.ush"
#include "RayTracingUpscaleCommon.ush"
#include "RayTracingGIDenoiseCommon.ush"

float4x4 InverseWVPMatrix;
float4x4 WVPMatrix;

int Enable;
int UseSH;
int2 DenoiseDim;
int2 GBufferDim;

float BlendWeight;
float NormalKernel;
float DepthKernel;
float ColorKernel;
float AOKernel;
float RandomRotation;
float BaseRadius;

Texture2D DepthTextureThis;

Texture2D NormalTextureThis;

Texture2D<uint4>   InputColor;
Texture2D<float4>   InputMoment;

RWTexture2D<uint4> OutputColor;

SamplerState LinearSampler;

float ToViewSpace(float4x4 invProj, float depth)
{
	return (invProj[2][2] * depth + invProj[3][2]) / (invProj[2][3] * depth + invProj[3][3]);
}

[numthreads(16, 16, 1)]
void SpatialFilter_CS(uint3 threadIdx : SV_DispatchThreadID)
{
	float   gPhiColor = ColorKernel;
	float   gPhiNormal = NormalKernel;

	float4 fragCoord = float4(threadIdx.xy, 0, 0);
	int2 ipos = int2(fragCoord.xy);

	float4 moment = InputMoment[ipos];
	float h = moment.a;
	int2 screenSize = DenoiseDim;
	float4 indirectCenter0; 
	float2 indirectCenter1;
	float VarLast;
	UnpackColorData(InputColor[ipos], indirectCenter0, indirectCenter1, VarLast);

	float spatialFrame = 4;
	if (Enable != 0 && h < spatialFrame) // not enough temporal history available
	{
		float sumWIndirect = 0.0;
		float3  sumDirect = float3(0.0, 0.0, 0.0);
		float4  sumIndirect0 = 0;
		float2  sumIndirect1 = 0;
		float4  sumMoments = float4(0.0, 0.0, 0.0, 0.0);

		const float4  directCenter = 0;

		//int2 iposG = int2(ipos / float2(DenoiseDim) * float2(GBufferDim));
		int2 iposG = GetPixelCoord(ipos);
		int2 GBufferStep = GetPixelCoordStep();
		float3 normalCenter = DecodeNormal(NormalTextureThis[iposG].xyz);
		float depth = DepthTextureThis[iposG].r;
		float dp0 = DepthTextureThis[iposG + int2(1, 0)].r;
		float dn0 = DepthTextureThis[iposG - int2(1, 0)].r;
		float d0p = DepthTextureThis[iposG + int2(0, 1)].r;
		float d0n = DepthTextureThis[iposG - int2(0, 1)].r;
		float deltaD = max(min(abs(dp0 - depth), abs(dn0 - depth)), min(abs(d0p - depth), abs(d0n - depth))) * 1;
		float2 zCenter = float2(depth, deltaD);

		if (zCenter.x < 0)
		{
			// current pixel does not a valid depth => must be envmap => do nothing
			OutputColor[ipos] = PackColorData(indirectCenter0, indirectCenter1, VarLast);
			return;
		}

		const float lDirectCenter = DenoiseLuminance(indirectCenter0, normalCenter, UseSH);
		const float lIndirectCenter = lDirectCenter;
		const float phiLDirect = gPhiColor;
		const float phiLIndirect = gPhiColor;
		const float phiDepth = max(zCenter.y, 1e-5) * 10.0 * DepthKernel;

		// compute first and second moment spatially. This code also applies cross-bilateral
		// filtering on the input color samples
		const int radius = 3;

		for (int yy = -radius; yy <= radius; yy++)
		{
			for (int xx = -radius; xx <= radius; xx++)
			{
				int2 offset = int2(xx, yy);
				const int2 p = ipos + offset;
				const bool inside = all(p >= int2(0, 0)) && all(p < screenSize);
				const bool samePixel = (offset.x == 0) && (offset.y == 0);
				const float kernel = 1.0;

				if (inside)
				{

					const float3 directP = 0;
					float4 C0Last;
					float2 C1Last;
					float VarLast;
					UnpackColorData(InputColor[p], C0Last, C1Last, VarLast);
					const float4 momentsP = InputMoment[p];

					const float lDirectP = 0;
					const float lIndirectP = DenoiseLuminance(C0Last, normalCenter, UseSH);

					float2 zP;
					int2 pG = iposG + GBufferStep * offset;
					zP.x = DepthTextureThis[pG].r;

					float3 normalP = DecodeNormal(NormalTextureThis[pG].xyz);
					float2 w = ComputeWeight(
						zCenter.x, zP.x, phiDepth * length(offset * GBufferStep),
						normalCenter, normalP, gPhiNormal,
						lDirectCenter, lDirectP, phiLDirect,
						lIndirectCenter, lIndirectP, phiLIndirect);

					const float wIndirect = w.y;

					sumWIndirect += wIndirect;
					sumIndirect0 += C0Last * wIndirect;
					sumIndirect1 += C1Last * wIndirect;

					sumMoments += momentsP * wIndirect;
				}
			}
		}

		// Clamp sums to >0 to avoid NaNs.
		sumWIndirect = max(sumWIndirect, 1e-9f);
		sumIndirect0 /= sumWIndirect;
		sumIndirect1 /= sumWIndirect;
		sumMoments /= sumWIndirect;

		// compute variance for direct and indirect illumination using first and second moments
		float variance = sumMoments.g - sumMoments.r * sumMoments.r;

		// give the variance a boost for the first frames
		variance *= pow(spatialFrame / h, 2);
		variance = max(variance, 0.001);

		if (h <= 1)
		{
			variance = max(1e8, variance);
		}

		OutputColor[ipos] = PackColorData(sumIndirect0, sumIndirect1, variance);
		return;
	}
	else
	{
		// do nothing, pass data unmodified
		OutputColor[ipos] = PackColorData(indirectCenter0, indirectCenter1, VarLast);
		return;
	}
}