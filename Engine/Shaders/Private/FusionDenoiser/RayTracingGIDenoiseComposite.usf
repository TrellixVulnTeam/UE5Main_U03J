#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "../SceneTextureParameters.ush"
#include "RayTracingUpscaleCommon.ush"
#include "/Engine/Public/Platform.ush"
#include "RayTracingDenoiseCommon.ush"


float4 		ViewportInfo;
float4x4 	InverseProjectionMatrix;
float 		DenoiseBufferScale;
float 		DiffuseBoost;
float 		SHSharpness;
float4 		ClearColor;
uint2 		CoarseDim;
int2 		GBufferDim;
int2 		DenoiseDim;
int 		UseSH;

Texture2D<float> DepthTexture;
Texture2D<float3> NormalTexture;
Texture2D<uint4> DenoiseTexture;
Texture2D<float4> MomentTexture;
int DebugMode;

#define SHOW_DENOISED_COLOR	0
#define SHOW_VARIANCE		1
#define SHOW_MOMENT1		2
#define SHOW_MOMENT2		3
#define SHOW_HISTORY		4
#define SHOW_MOTION_VECTOR	5
#define SHOW_AO				6
#define SHOW_RAW_OUTPUT		7

#define SEMANTIC(x) : x;

struct PS_SCREEN_QUAD_INPUT
{
	noperspective float4 f2TexCoord	SEMANTIC(TEXCOORD0)
	float4 f4Position	SEMANTIC(SV_Position)
};

float UVToViewZ(float2 f2UV, float fViewDepth)
{
	float2 cs = float2(2.0f * f2UV.x - 1.0f, 2.0f * (1.0f - f2UV.y) - 1.0f);
	float2 D = mul(float4(0, 0, fViewDepth, 1.0f), InverseProjectionMatrix).zw;
	return D.x / D.y;
}

float FetchViewZ(int3 pos)
{
	float2 uv_pos = (float2(pos.xy) + float2(0.5f, 0.5f)) * ViewportInfo.zw;
	float fHardwareDepth = DepthTexture.Load(pos).x;
	return fHardwareDepth;
}

float FetchViewZ(int3 pos, inout float hwD)
{
	float2 uv_pos = (float2(pos.xy) + float2(0.5f, 0.5f)) * ViewportInfo.zw;
	float fHardwareDepth = DepthTexture.Load(pos).x;

	hwD = fHardwareDepth;

	return UVToViewZ(uv_pos, fHardwareDepth);
}

float3 GetViewSpacePosFromDepth(float2 f2ScreenCoord, float D)
{
	float2 VP = ViewportInfo.xy;
	float2 TC = float2((f2ScreenCoord.x + 0.5) / VP.x, (f2ScreenCoord.y + 0.5) / VP.y);
	float4 V = mul(float4(TC.x * 2.0f - 1.0f, TC.y * -2.0f + 1.0f, D, 1.0f), InverseProjectionMatrix);
	V /= V.w;

	return V.xyz;
}

float ComputeUpsampleWeight(float z0, float z1, float3 n0, float3 n1)
{
	float w = rcp(abs(z0 - z1) + 1.0f);
	w *= w * w;
	w *= pow(saturate(dot(n0, n1)), 20) + 1e-5;
	return w;
}

float4 Composite_PS(PS_SCREEN_QUAD_INPUT IN) : SV_Target0
{

	float bufferScaling = round(1 / DenoiseBufferScale);
	float   fOutCol;
	float   fTotalWeight = 0.0f;
	float   fVolTotalWeight = 0.0f;
	uint3   adr = int3(int2(IN.f4Position.xy), 0);
	int3   ladr = adr / (bufferScaling);
	int3   uladr = ladr* (bufferScaling);

	uint2 GBufferStep;
	GetBasePixelCoordFromUpscaledPixelCoord(adr.xy, 0, ladr.xy, uladr.xy, GBufferStep);

	float3 weight = saturate(1 - (adr - uladr) / float3(GBufferStep,1));
	float4  f4BiWeights = float4(weight.x * weight.y, (1 - weight.x) * weight.y, weight.x * (1 - weight.y), (1 - weight.x) * (1 - weight.y));
	float4  fI = 0.0f;
	float4 f4Albedo = 1;

	float3 f3HiN = DecodeNormal(NormalTexture.Load(adr).xyz);
	float  fD;
	float  fHiZ = FetchViewZ(adr, fD);
	if (fD >= 1 || fD <= 0)
	{
		return 0;
	}

	float3 VSPos = GetViewSpacePosFromDepth(float2(adr.xy), fD);

	int2 uladr1 = clamp(uladr.xy + GBufferStep, 0, GBufferDim - 1);

	float  fLoZ0 = FetchViewZ(uladr);
	float  fLoZ1 = FetchViewZ(int3(uladr1.x, uladr.y, 0));
	float  fLoZ2 = FetchViewZ(int3(uladr.x, uladr1.y, 0));
	float  fLoZ3 = FetchViewZ(int3(uladr1.x, uladr1.y, 0));

	float3 f3LoN0 = DecodeNormal(NormalTexture.Load(uladr).xyz);
	float3 f3LoN1 = DecodeNormal(NormalTexture.Load(int3(uladr1.x, uladr.y, 0)).xyz);
	float3 f3LoN2 = DecodeNormal(NormalTexture.Load(int3(uladr.x, uladr1.y, 0)).xyz);
	float3 f3LoN3 = DecodeNormal(NormalTexture.Load(int3(uladr1.x, uladr1.y, 0)).xyz);

	float  fWeight0 = ComputeUpsampleWeight(fHiZ, fLoZ0, f3HiN, f3LoN0) * f4BiWeights.x;
	float  fWeight1 = ComputeUpsampleWeight(fHiZ, fLoZ1, f3HiN, f3LoN1) * f4BiWeights.y;
	float  fWeight2 = ComputeUpsampleWeight(fHiZ, fLoZ2, f3HiN, f3LoN2) * f4BiWeights.z;
	float  fWeight3 = ComputeUpsampleWeight(fHiZ, fLoZ3, f3HiN, f3LoN3) * f4BiWeights.w;
	
	float4 F0, F1, F2, F3;
	float2 G0, G1, G2, G3;
	if (DebugMode == SHOW_VARIANCE)
	{
		float4  indirectCenter0;
		float2  indirectCenter1;
		float variance;
		UnpackColorData(DenoiseTexture.Load(ladr, int2(0, 0)), indirectCenter0, indirectCenter1, variance);
		return float4(sqrt(variance)*50, 0, 0, 1);
	}
	else if (DebugMode == SHOW_MOMENT1)
	{
		return float4(MomentTexture.Load(ladr, int2(0, 0)).r * 1, 0, 0, 1);
	}
	else if (DebugMode == SHOW_MOMENT2)
	{
		return float4(MomentTexture.Load(ladr, int2(0, 0)).g * 1, 0, 0, 1);
	}
	else if (DebugMode == SHOW_AO)
	{
		return float4(sqrt(MomentTexture.Load(ladr, int2(0, 0)).b), 0, 0, 1);
	}
	else if (DebugMode == SHOW_HISTORY)
	{
		return float4(10.0 / MomentTexture.Load(ladr, int2(0, 0)).a, 0, 0, 1);
	}
	else if (DebugMode == SHOW_MOTION_VECTOR)
	{
		float4 Velocity = GBufferVelocityTexture.Load(uladr, int2(0, 0));
		if (Velocity.x > 0.0)
		{
			Velocity.xyz = DecodeVelocityFromTexture(Velocity) * 100;
		}
		return float4(Velocity.xy, 0, 1);
	}
	else if (DebugMode == SHOW_RAW_OUTPUT)
	{
		float4  indirectCenter0;
		float2  indirectCenter1;
		float variance;
		UnpackColorData(DenoiseTexture.Load(ladr, int2(0, 0)), indirectCenter0, indirectCenter1, variance);
		return float4(DenoiseTexture.Load(ladr, int2(0, 0)).rgb * DiffuseBoost, 1);
	}
	else
	{
		float Var;
		int3 Address = clamp(ladr + int3(0, 0, 0), 0, int3(DenoiseDim - 2, 0));
		UnpackColorData(DenoiseTexture.Load(Address), F0, G0, Var);

		Address = clamp(ladr + int3(1, 0, 0), 0, int3(DenoiseDim - 2, 0));
		UnpackColorData(DenoiseTexture.Load(Address), F1, G1, Var);

		Address = clamp(ladr + int3(0, 1, 0), 0, int3(DenoiseDim - 2, 0));
		UnpackColorData(DenoiseTexture.Load(Address), F2, G2, Var);

		Address = clamp(ladr + int3(1, 1, 0), 0, int3(DenoiseDim - 2, 0));
		UnpackColorData(DenoiseTexture.Load(Address), F3, G3, Var);
	}

	float4 TotalF = F0 * fWeight0 + F1 * fWeight1 + F2 * fWeight2 + F3 * fWeight3;
	float2 TotalG = G0 * fWeight0 + G1 * fWeight1 + G2 * fWeight2 + G3 * fWeight3;
	float TotalWeight = max(1e-30, fWeight0 + fWeight1 + fWeight2 + fWeight3);

	float4 AvgF = TotalF / TotalWeight;
	float2 AvgG = TotalG / TotalWeight;

	float3 FinalColor;
	if (UseSH)
	{
		// Reconstruct incoming lighting from denoised SH coefs
		// The SHSharpness sharpens normal details.
		float d = pow(saturate(dot(f3HiN.xyz, normalize(AvgF.xyz))), max(1e-2, SHSharpness)) * (SHSharpness + 2) / (3) * length(AvgF.xyz);
		float Y = 2.0 * (1.023326 * d + 0.886226 * AvgF.w);
		Y = max(Y, 0);

		float2 CoCg = AvgG * 0.282095 * Y / (AvgF.w + 1e-6);
		float T = Y - CoCg.y * 0.5;
		float G = CoCg.y + T;
		float B = T - CoCg.x * 0.5;
		float R = B + CoCg.x;
		FinalColor = float3(R, G, B);
	}
	else
	{
		FinalColor = AvgF.xyz;
	}
	FinalColor *= DiffuseBoost;

	return float4(FinalColor, 1);
}
