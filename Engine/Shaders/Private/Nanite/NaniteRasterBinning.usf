// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../SceneData.ush"
#include "NaniteAttributeDecode.ush"

#if (RASTER_BIN_PASS == NANITE_RASTER_BIN_CLASSIFY)
	#define RASTER_BIN_CLASSIFY	1
	#define RASTER_BIN_SCATTER	0
	#define RASTER_BIN_RESERVE	0
#elif (RASTER_BIN_PASS == NANITE_RASTER_BIN_SCATTER)
	#define RASTER_BIN_CLASSIFY	0
	#define RASTER_BIN_SCATTER	1
	#define RASTER_BIN_RESERVE	0
#else
	#define RASTER_BIN_CLASSIFY	0
	#define RASTER_BIN_SCATTER	0
	#define RASTER_BIN_RESERVE	1
#endif

// .x = count of SW clusters in bin
// .y = count of HW clusters in bin
// .z = offset of contiguous cluster range in global buffer
// .w = unused (TODO: PROG_RASTER) separate bin for HW?
RWStructuredBuffer<uint4> OutRasterizerBinHeaders;

uint2 GetRasterizerBinCount(uint BinIndex)
{
	// .x = SW cluster count in rasterizer bin
	// .y = HW cluster count in rasterizer bin
	return OutRasterizerBinHeaders[BinIndex].xy;
}

uint GetRasterizerBinCapacity(uint BinIndex)
{
	const uint2 BinCount = GetRasterizerBinCount(BinIndex);
	return (BinCount.x + BinCount.y);
}

void SetRasterizerBinOffset(uint BinIndex, uint BinOffset)
{
	OutRasterizerBinHeaders[BinIndex].z = BinOffset;
}

uint GetRasterizerBinOffset(uint BinIndex)
{
	return OutRasterizerBinHeaders[BinIndex].z;
}

#if RASTER_BIN_RESERVE

uint RasterBinCount;

RWStructuredBuffer<uint> OutRangeAllocator;
RWBuffer<uint> OutRasterizerBinArgsSWHW;

uint AllocateRasterizerBinRange(uint ClusterCount)
{
	uint RangeStart;
	InterlockedAdd(OutRangeAllocator[0], ClusterCount, RangeStart);
	return RangeStart;
}

[numthreads(64, 1, 1)]
void RasterBinReserve(uint RasterBinIndex : SV_DispatchThreadID)
{
	if (RasterBinIndex < RasterBinCount)
	{
		const uint RasterBinCapacity = GetRasterizerBinCapacity(RasterBinIndex);
		const uint RasterBinOffset = AllocateRasterizerBinRange(RasterBinCapacity);
		SetRasterizerBinOffset(RasterBinIndex, RasterBinOffset);

		const uint ArgsOffset = (RasterBinIndex * NANITE_RASTERIZER_ARG_COUNT);
		WriteRasterizerArgsSWHW(OutRasterizerBinArgsSWHW, ArgsOffset, 0u, 0u);
	}
}

#else

Buffer<uint> InClusterOffsetSWHW;

StructuredBuffer<uint2> InClusterCountSWHW;
StructuredBuffer<uint2> InTotalPrevDrawClusters;

ByteAddressBuffer MaterialSlotTable;

#if RASTER_BIN_SCATTER
RWBuffer<uint> OutRasterizerBinArgsSWHW;
RWStructuredBuffer<uint2> OutRasterizerBinData;
#endif

#if RASTER_BIN_CLASSIFY
void IncrementRasterizerBinCount(uint BinIndex, bool bSoftware)
{
	if (bSoftware)
	{
		InterlockedAdd(OutRasterizerBinHeaders[BinIndex].x, 1u);
	}
	else
	{
		InterlockedAdd(OutRasterizerBinHeaders[BinIndex].y, 1u);
	}
}
#elif RASTER_BIN_SCATTER
uint AllocateRasterizerBinCluster(uint BinIndex, bool bSoftware)
{
	uint ClusterOffset;
	const uint ArgsOffset = (BinIndex * NANITE_RASTERIZER_ARG_COUNT);
	if (bSoftware)
	{
		const uint Offset = 0u;
		InterlockedAdd(OutRasterizerBinArgsSWHW[ArgsOffset + Offset], 1u, ClusterOffset);
	}
	else
	{
		const uint Capacity = GetRasterizerBinCapacity(BinIndex);
		const uint Offset = CondMask((RenderFlags & NANITE_RENDER_FLAG_MESH_SHADER) || (RenderFlags & NANITE_RENDER_FLAG_PRIMITIVE_SHADER), 4u, 5u);
		InterlockedAdd(OutRasterizerBinArgsSWHW[ArgsOffset + Offset], 1u, ClusterOffset);
		ClusterOffset = (Capacity - ClusterOffset - 1u); // HW writes from the top, SW writes from the bottom
	}
	return GetRasterizerBinOffset(BinIndex) + ClusterOffset;
}
#endif

void ExportRasterizerBin(uint RasterizerBin, uint ClusterIndex, uint RangeStart, uint RangeEnd, bool bSoftware)
{
#if RASTER_BIN_CLASSIFY
	IncrementRasterizerBinCount(RasterizerBin, bSoftware);
#elif RASTER_BIN_SCATTER
	const uint BinClusterMapping = AllocateRasterizerBinCluster(RasterizerBin, bSoftware);
	OutRasterizerBinData[BinClusterMapping].x = ClusterIndex;
	OutRasterizerBinData[BinClusterMapping].y = (RangeStart << 16u) | RangeEnd;
#endif
}

[numthreads(64, 1, 1)]
void RasterBinBuild(uint RelativeClusterIndex : SV_DispatchThreadID)
{
	const uint SWClusterCount = InClusterCountSWHW[0].x;
	const uint HWClusterCount = InClusterCountSWHW[0].y;

	const bool bSoftware = RelativeClusterIndex < SWClusterCount;
	const uint ClusterCount = SWClusterCount + HWClusterCount;

	if (RelativeClusterIndex < ClusterCount)
	{
		RelativeClusterIndex = CondMask(bSoftware, RelativeClusterIndex, RelativeClusterIndex - SWClusterCount);

		uint ClusterOffset = 0;

		const bool bHasPrevDrawData = (RenderFlags & NANITE_RENDER_FLAG_HAS_PREV_DRAW_DATA) != 0u;
		BRANCH
		if (bHasPrevDrawData)
		{
			ClusterOffset += CondMask(bSoftware, InTotalPrevDrawClusters[0].x, InTotalPrevDrawClusters[0].y);
		}

	#if IS_POST_PASS
		ClusterOffset += CondMask(bSoftware, InClusterOffsetSWHW[0], InClusterOffsetSWHW[GetHWClusterCounterIndex(RenderFlags)]);
	#endif

		uint VisibleClusterIndex = RelativeClusterIndex + ClusterOffset;

		// HW clusters are written from the top
		VisibleClusterIndex = CondMask(bSoftware, VisibleClusterIndex, (MaxVisibleClusters - 1) - VisibleClusterIndex);

		FVisibleCluster VisibleCluster		= GetVisibleCluster(VisibleClusterIndex, VIRTUAL_TEXTURE_TARGET);
		FInstanceSceneData InstanceData		= GetInstanceSceneData(VisibleCluster, false);
		FCluster Cluster					= GetCluster(VisibleCluster.PageIndex, VisibleCluster.ClusterIndex);

		// TODO: Scalarize and reduce global atomics
		// TODO: Embed fast path material uint in FVisibleCluster
		// TODO: Upload uniform with default material bin index, directly allocate/store indirections into 0th range
		// TODO: Optimize and/or separate out slow path into another dispatch? (possibly with groupshared bin tracking to avoid searching)

		BRANCH
		if (IsMaterialFastPath(Cluster))
		{
			uint RasterizerBin0 = 0;
			uint RasterizerBin1 = 0;
			uint RasterizerBin2 = 0;

			uint RasterizerLen0 = 0;
			uint RasterizerLen1 = 0;
			uint RasterizerLen2 = 0;

			// Length is remaining triangles after Material0 and Material1
			const uint Material2Length = Cluster.NumTris - (Cluster.Material0Length + Cluster.Material1Length);

			// The 0th material range is always non-zero length
			{
				RasterizerBin0 = GetMaterialRasterSlotFromIndex(Cluster.Material0Index, InstanceData.PrimitiveId, MaterialSlotTable);
			}

			BRANCH
			if (Cluster.Material1Length > 0u)
			{
				RasterizerBin1 = GetMaterialRasterSlotFromIndex(Cluster.Material1Index, InstanceData.PrimitiveId, MaterialSlotTable);
			}

			BRANCH
			if (Material2Length > 0)
			{
				RasterizerBin2 = GetMaterialRasterSlotFromIndex(Cluster.Material2Index, InstanceData.PrimitiveId, MaterialSlotTable);
			}

			if (RasterizerBin0 == RasterizerBin1 && RasterizerBin0 == RasterizerBin2)
			{
				RasterizerLen0 = Cluster.NumTris;
			}
			else if (RasterizerBin0 == RasterizerBin1)
			{
				RasterizerLen0 = (Cluster.Material0Length + Cluster.Material1Length);
				RasterizerLen2 = Material2Length;
			}
			else if (RasterizerBin1 == RasterizerBin2)
			{
				RasterizerLen0 = Cluster.Material0Length;
				RasterizerLen1 = Cluster.NumTris - Cluster.Material0Length;
			}
			else
			{
				RasterizerLen0 = Cluster.Material0Length;
				RasterizerLen1 = Cluster.Material1Length;
				RasterizerLen2 = Material2Length;
			}

			// The 0th material range is always non-zero length
			{
				ExportRasterizerBin(RasterizerBin0, RelativeClusterIndex, 0u, RasterizerLen0, bSoftware);
			}

			BRANCH
			if (RasterizerLen1 > 0)
			{
				const uint Range1Start = RasterizerLen0;
				const uint Range1End   = Range1Start + RasterizerLen1;
				ExportRasterizerBin(RasterizerBin1, RelativeClusterIndex, Range1Start, Range1End, bSoftware);
			}

			BRANCH
			if (RasterizerLen2 > 0)
			{
				const uint Range2Start = (RasterizerLen0 + RasterizerLen1);
				const uint Range2End   = Range2Start + RasterizerLen2;
				ExportRasterizerBin(RasterizerBin2, RelativeClusterIndex, Range2Start, Range2End, bSoftware);
			}
		}
		else
		{
			uint CurrentRangeBin = 0xFFFFFFFFu;
			uint CurrentRangeStart = 0;
			uint CurrentRangeEnd = 0;

			uint TableOffset = Cluster.PageBaseAddress + Cluster.MaterialTableOffset * 4u;
			LOOP for (uint TableEntry = 0; TableEntry < Cluster.MaterialTableLength; ++TableEntry)
			{
				const uint EncodedRange = ClusterPageData.Load(TableOffset);
				TableOffset += 4;

				const uint TriStart			= BitFieldExtractU32(EncodedRange, 8, 0);
				const uint TriLength		= BitFieldExtractU32(EncodedRange, 8, 8);
				const uint MaterialIndex	= BitFieldExtractU32(EncodedRange, 6, 16);
				const uint RasterizerBinN	= GetMaterialRasterSlotFromIndex(MaterialIndex, InstanceData.PrimitiveId, MaterialSlotTable);

				// Check if raster slot matches the current run, and that the triangle range is contiguous.
				const bool bMergeRange = (RasterizerBinN == CurrentRangeBin);
				if (bMergeRange)
				{
					// Update current range
					CurrentRangeEnd = TriStart + TriLength;
				}
				else
				{
					// Not merging previous range, and previous range has valid triangles that need to be flushed
					BRANCH
					if (CurrentRangeEnd > 0)
					{
						ExportRasterizerBin(CurrentRangeBin, RelativeClusterIndex, CurrentRangeStart, CurrentRangeEnd, bSoftware);
					}

					CurrentRangeBin   = RasterizerBinN;
					CurrentRangeStart = TriStart;
					CurrentRangeEnd   = CurrentRangeStart + TriLength;
				}
			}

			// Need to flush current range
			ExportRasterizerBin(CurrentRangeBin, RelativeClusterIndex, CurrentRangeStart, CurrentRangeEnd, bSoftware);
		}
	}
}

#endif