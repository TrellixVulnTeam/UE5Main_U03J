#include "../Common.ush"
#define USE_PREEXPOSURE 0
#define USE_TONEMAP 1
#define SUPPORT_CONTACT_SHADOWS		0

#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "../SceneTextureParameters.ush"
#include "../ScreenSpaceDenoise/SSDPublic.ush"
#include "../MortonCode.ush"
#include "../BRDF.ush"

#include "../RayTracing/RayTracingCommon.ush"
#include "../RayTracing/RayTracingDeferredShadingCommon.ush"
#include "../RayTracing/RayTracingReflectionsCommon.ush"
#include "../RayTracing/RayTracingDeferredReflections.ush"

#include "ReservoirManagement.ush"

RWTexture2D<float4>                             ColorOutput;
RWTexture2D<float4>                             DebugTex;

int    InputSlice;

RaytracingAccelerationStructure                 TLAS;
float ReflectionMaxNormalBias;
float ReflectionMaxRoughness;
float ReflectionSmoothBias;
float2 UpscaleFactor;
int    ApproxVisibility;
int  FeedbackVisibility;

Texture2D RawReflectionColor;

float3 FastTonemap(float3 c)
{
	return c * rcp(max3(c.r, c.g, c.b) + 1.0);
}

float3 InvFastTonemap(float3 c)
{
	return c * rcp(1.0 - max3(c.r, c.g, c.b));
}

#if USE_TONEMAP
#	define TONEMAP(x) FastTonemap(x)
#	define INV_TONEMAP(x) InvFastTonemap(x)
#else // USE_TONEMAP
#	define TONEMAP(x) (x)
#	define INV_TONEMAP(x) (x)
#endif // USE_TONEMAP

RAY_TRACING_ENTRY_RAYGEN(RestirEvaluateRGS)
{

    uint2 DispatchThreadId = DispatchRaysIndex().xy + View.ViewRectMin.xy;
    uint2 PixelCoord = GetPixelCoord(DispatchThreadId, UpscaleFactor.x);
	DebugTex[DispatchThreadId] = 0;
    // Get G-Buffer surface data
    FGBufferData GBuffer = GetGBufferDataFromSceneTexturesLoad(PixelCoord);
	GBuffer.Roughness = GetRayTracingClearCoatApproximateRoughness(GBuffer);
	GBuffer.Roughness = ApplySmoothBias(GBuffer.Roughness, ReflectionSmoothBias);

    float Depth = GBuffer.Depth;
    float DeviceZ = SceneDepthTexture.Load(int3(PixelCoord, 0)).r;

    float3 TranslatedWorldPosition;
    float3 CameraDirection;
    ReconstructTranslatedWorldPositionAndCameraDirectionFromDeviceZ(PixelCoord, DeviceZ, TranslatedWorldPosition, CameraDirection);
    float3 V = -CameraDirection;
    const bool bIsDepthValid = DeviceZ > 0.0;
	const float RoughnessFade = GetRoughnessFade(GBuffer.Roughness, ReflectionMaxRoughness);

	const bool bIsValidPixel = GBuffer.ShadingModelID != SHADINGMODELID_UNLIT && bIsDepthValid && RoughnessFade > 0;

    Reservoir risSample = Reservoir::Empty();
	float3 ExitantRadiance = 0.0;
	float RayDistance = 0.0;
	float HitCount = 0.0;

	if (bIsValidPixel)
	{
		{
			risSample = Reservoir::Load(ReadReservoirData(DispatchThreadId, InputSlice));
			//if (risSample.sampleRef.IsValid())
			{
                const float NoV = max(0, dot(GBuffer.WorldNormal, V));

		        const float a2 = max(1e-5, Pow4(GBuffer.Roughness));

                float3 LightPosition = risSample.sampleRef.Position + LWCHackToFloat(PrimaryView.PreViewTranslation);
				float3 Direction = (LightPosition - TranslatedWorldPosition);
				
				RayDesc Ray;	
				Ray.Origin = TranslatedWorldPosition;
				Ray.Direction = normalize(Direction);
				Ray.TMin = 0;
				Ray.TMax = length(Direction) - 1e-3;

				float3 BiasNormal = GBuffer.WorldNormal;
				if ( dot(BiasNormal, Ray.Direction) < 0.0)
				{
					BiasNormal = -BiasNormal;
				}
				ApplyPositionBias(Ray, BiasNormal, ReflectionMaxNormalBias);

				uint RayFlags = 0;
				const uint InstanceInclusionMask = RAY_TRACING_MASK_SHADOW;


                RayFlags |= RAY_FLAG_FORCE_OPAQUE;

                // #if !ENABLE_TWO_SIDED_GEOMETRY
                //         RayFlags |= RAY_FLAG_CULL_BACK_FACING_TRIANGLES;
                // #endif
				bool Visible = true;
				FMinimalPayload MinimalPayload = (FMinimalPayload)0;
				if ( ApproxVisibility )
				{
					MinimalPayload = TraceVisibilityRay(
						TLAS,
						RayFlags,
						InstanceInclusionMask,
						PixelCoord,
						Ray);
					Visible = !MinimalPayload.IsHit();
				}
				if ( Visible )
				{
                    const float3 SampleL = Ray.Direction;
                    const float3 SampleH = normalize(V + SampleL);
                    const float SampleNoH = max(0, dot(GBuffer.WorldNormal, SampleH));
                    const float SampleNoL = max(0, dot(GBuffer.WorldNormal, SampleL));
                    const float VoH = saturate(dot(V, SampleH));

                    const float D = D_GGX(a2, SampleNoH);
                    float Vis = Vis_Smith(a2, NoV, SampleNoL);
                    const float LocalBRDF = D * Vis * SampleNoL;

					ExitantRadiance +=  risSample.sampleRef.Irradiance * risSample.weightSum * LocalBRDF;

					RayDistance += Ray.TMax;
					HitCount += 1.0f;
					float3 color = risSample.weightSum  ;
					DebugTex[DispatchThreadId] = float4(color ,1.0);
				}
				else
				{
					HitCount += 1.0f;
					RayDistance += MinimalPayload.HitT;
					if (FeedbackVisibility)
					{
						risSample.weightSum = 0.0f;
						risSample.targetPdf = 0.0f;
						risSample.M = 0;
					}
				}
            }
            // else
			// {
			// 	// sample occluded, kill it for the history
			// 	risSample = Reservoir::Empty();
			// }
            // WriteReservoirHistoryData(DispatchThreadId, 0, ReadReservoirData(DispatchThreadId, 0));
        }

		RayDistance /= max(HitCount, 1.0);

		// Apply the pre-exposure scale to the resulting shaded value
// #if USE_PREEXPOSURE
		// ExitantRadiance *= View.PreExposure;
// #endif
		//ExitantRadiance = INV_TONEMAP(ExitantRadiance);
    }
    //else
	{
		// Invalid pixel, write empty reservoir
		WriteReservoirHistoryData(DispatchThreadId, 0, ReadReservoirData(DispatchThreadId, 0));
	}


	float alpha = RawReflectionColor.Load(uint3(DispatchThreadId, 0)).a;
    ColorOutput[DispatchThreadId] = float4(ExitantRadiance,alpha);
	// float3 color = risSample.weightSum;
	// DebugTex[DispatchThreadId] = float4(color ,1.0);
}